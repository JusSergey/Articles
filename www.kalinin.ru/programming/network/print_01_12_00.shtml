<html><head><title>ALK :: Сети :: Неблокирующий connect().</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/network/01_12_00.shtml">http://www.kalinin.ru/programming/network/01_12_00.shtml</a><br>
<hr>
<br>

<h1>Неблокирующий connect()
</h1>
<p align="right">01.12.00</p>
 
    <p align="justify">
      В продолжение темы о замене блокирующего вызова <code>gethostbyname()</code>,
      хочется рассказать о другой функции интерфейса сокетов, <code>connect()</code>. 
      Она имеет следующий прототип:
    </p>
<code>
int
connect(int s, const struct sockaddr *name, socklen_t namelen);
</code>
    <p align="justify">
      Эта функция предназначена для установки соединения с удаленной машиной после того,
      как на локальной машине уже открыт сокет под это соединение.
    </p>
    <p align="justify">
      Функция забавна уже тем, как в нее передаются параметры. Все дело
      в том, что она может использоваться с любыми протоколами
      передачи данных (а не только TCP/IP), поэтому второй параметр
      имеет странный тип "указатель на <code>struct sockaddr</code>",
      которая на самом деле содержит в себе лишь общие определения
      для всех протоколов. Пусть вас не смущает название этого параметра:
      <code>name</code> обозначает "имя" не в смысле имени DNS, а в смысле
      уникального идентификатора сокета (например парой ip-адрес и номер порта).
    </p>
    <p align="justify">
      Я не буду приводить примеры того, как эта функция используется,
      скорее всего вы и так все это можете найти в документации на вашу
      операционную систему. Дальше мне бы хотелось немного поговорить
      о том, как эта функция будет работать.
    </p>
    <p align="justify">
      Проблема связанная с ней, опять заключается в том, что
      установка соединения вполне вероятно может быть очень
      длительной операцией за счет плохих каналов передачи данных.
      Ведь этот процесс заключается в том, что по сети передаются
      несколько пакетов "туда и обратно" с просьбой открыть сокет,
      послать подтверждение и прочее... то есть, фактически,
      <code>connect()</code> опять же ничем принципиально не отличается
      от функций чтения и записи данных в сокеты. Тем не менее, за счет
      использования <code>select()</code> мы можем читать из сокета и писать
      в сокет по готовности, а окончания <code>connect()</code> вынуждены ждать...
    </p>
    <p align="justify">
      Вообще говоря, операции ввода-вывода могут быть блокирующими, неблокирующими,
      управляемыми сигналами, асинхронными... Нас интересуют первые два типа
      подобных операций, как видно из названия:
    </p>
    <ul>
      <li>
	Блокирующие операции ввода-вывода приостанавливают процесс до окончания выполнения
	операции. Например, если что-то читается из сокета (вызовом <code>read()</code>),
	то управление вернется в программу только в том случае, если пришли
	реальные данные по этому соединению, либо произошла ошибка (например, разрыв
	связи). 
      </li>
      <li>
	Неблокирующие операции возвращают управление в процесс сразу же
	после вызова, завершая операцию параллельно с выполнением процесса.
      </li>
    </ul>
    <p align="justify">
      Реальные сетевые программы практически никогда не используют блокирующие
      функции: это было бы слишком медленно. Или, точнее, могут использовать
      блокирующий <code>read()</code>, но только удостоверившись в том, что 
      ему есть что прочитать посредством предварительного вызова <code>select()</code>.
    </p>
    <p align="justify">
      Но <code>connect()</code> все равно остается блокирующим! До тех пор, пока
      не будет установлена соответствующая опция сокета. То, о чем я хочу
      рассказать чуть ниже, не является фокусом, этот прием после Netscape очень давно применяется
      повсеместно, я сам вычитал это из Unix Network Programming, но почему-то 
      очень часто этого не делают.
    </p>
    <p align="justify">
      Все операции с сокетами можно сделать неблокирующими посредством 
      предварительного вызова функции <code>fcntl()</code>:      
    </p>
<pre>
int fd = socket(AF_INET, SOCK_STREAM, 0);
int flags = fcntl(fd, F_GETFL, 0);
if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1)
{
  /*
   * Не получилось...
   */
}
</pre>
    <p align="justify">
      "Неблокированность" сокета устанавливается вызовом <code>fcntl()</code>
      с параметром <code>F_SETFL</code> и соответствующим набором флагов, в который
      включен <code>O_NONBLOCK</code>. После этого можно не опасаясь вызывать
      <code>connect()</code>, вызывающий процесс продолжит свое выполнение
      в любом случае, даже если на установку соединения потребуется несколько
      десятков секунд:
    </p>
<pre>
if(connect(fd, (sockaddr*)&amp;servaddr, sizeof(servaddr)) != 0)
  {
</pre>
<table align="right" border="0" cellspacing="0" cellpadding="5" width="150">
<tr><td></td></tr>
<tr><td>&nbsp;</td>
<td bgcolor="#cccccc" width="100%" nowrap>Лирическое отступление:</font></td>
</tr>
<tr><td colspan="2"></td></tr>
<tr>
<td>&nbsp;</td>
<td>
    <p align="justify">
      Проверка кода ошибки после выполнения системного 
      вызова с ошибкой обязательна! Вообще говоря, 
      надо по крайней мере обрабатывать код ошибки
      <code>EINTR</code>, который является признаком
      того, что операция была прервана по сигналу,
      тогда вызов можно повторить.
    </p>
    <p align="justify">
      В случае с <code>EINTR</code>, конечно же,
      можно установить для всех "безопасных" 
      сигналов флаг <code>SA_RESTART</code>, после чего 
      системный вызов будет автоматически повторен, но 
      это пример тому, что если функция вернула ошибку, 
      то это еще не значит, что что-то прошло неправильно.
    </p>
</td></tr></table>
<pre>
    if(errno == EINPROGRESS)
      {
         /*
          * Это не ошибка, это признак
          * того, что соединение все еще
          * не установлено.
          */
      }
    else
      {
         /*
          * Произошла ошибка сразу же
          * при соединении.
          */
      }
  }
else
  {
      /*
       * Соединение было установлено за время
       * системного вызова, работа продолжается
       * традиционным способом.
       */ 
  }
</pre>
    <p align="justify">
      Единственный интерес здесь представляет проверка <code>errno</code>
      на <code>EINPROGRESS</code>, потому что после этого,
      перед тем как начать работу с сокетом, надо 
      будет сначала дождаться завершения открытия соединения
      (а что бы даром времени не терять, параллельно можно заняться
      другими делами). 
    </p>
    <p align="justify">
      Получить информацию о том, что сокет "готов", можно используя
      все тот же <code>select()</code>. Для этого надо установить
      файловый дескриптор сокета в обоих множествах (на чтение и на запись):
    </p>
<pre>
fd_set rfds, wfds;
struct timeval tv;
tv.tv_sec = 0; tv.tv_usec = 500;

FD_ZERO(&amp;rfds); 
FD_ZERO(&amp;wfds);

int max_fd = -1;

/*
 * Заполняем множества. Дескриптор 
 * сокета, с не открытым соединением
 * помещаем в оба множества.
 */
FD_SET(fd, &amp;wfds);
FD_SET(fd, &amp;rfds);
if(fd > max_fd) max_fd = fd;

select(max_fd + 1, &amp;rfds, &amp;wfds, NULL, &amp;tv);
</pre>
    <p align="justify">
      Если после выполнения <code>select()</code> интересующий
      нас дескриптор остался в каком-либо из множеств,
      то соединение завершено. Остается вопрос, как 
      определить, не произошла ли ошибка?
    </p>
<pre>
if(FD_ISSET(fd, &amp;wfds) || FD_ISSET(fd, &amp;rfds))
{
  socklen_t err_len;
  int error;
		
  err_len = sizeof(error);
  if(getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;err_len) < 0 || error != 0)
    {
      /*
       * Произошла ошибка соединения.
       */
    }
  else
    {
      /*
       * Все нормально.
       */
    }
}
</pre>
    <p align="justify">
      Теперь можно обработать ошибку или продолжить нормальное выполнение программы.
    </p>
    <p align="justify">
      Понятно, что в случае одного сокета в программе, такой подход,
      скорее всего, будет нерационален. Но при обработке большого числа
      открытых сокетов с использованием <code>select()</code>, неблокирующий
      <code>connect()</code> будет очень прост в реализации и, одновременно, очень
      эффективен. 
    </p>
    <p align="justify">
      Обычно подпрограмму, которая работает с <code>select()</code> удобно
      вынести в отдельный поток управления и общаться с ней
      посредством очередей сокетов "на вход" и полученных данных "на выходе". 
    </p>

<h2>Резюме</h2>
    <p align="justify">
      Неблокирующий <code>connect()</code> является хорошим дополнением к 
      правильно написанному клиенту. Скорость работы с сетью может вырасти
      значительно (в зависимости от того, насколько плох канал между
      клиентом и сервером, а, точнее, насколько много серверов с хорошим каналом
      и сколько серверов с плохим каналом). Очень прост в реализации и очень удобен:
      вообще, неблокирующие операции ввода-вывода, на мой взгляд, по соотношению
      скорости работы к удобству программирования самые приемлимые. 
    </p>



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td>W.&nbsp;Richard&nbsp;Stevens</td>
<td width="100%">
     Unix Network programming, volume 1.
</td></tr>
<tr><td>W.&nbsp;Richard&nbsp;Stevens</td>
<td width="100%">
     TCP/IP Illustrated, volume 1.
</td></tr>
<tr><td>W.&nbsp;Richard&nbsp;Stevens, </td>
<td width="100%">
     TCP/IP Illustrated, volume 2.
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
