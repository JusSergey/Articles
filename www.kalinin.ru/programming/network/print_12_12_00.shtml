<html><head><title>ALK :: Сети :: Событийная модель в WinSock.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/network/12_12_00.shtml">http://www.kalinin.ru/programming/network/12_12_00.shtml</a><br>
<hr>
<br>

<h1>Событийная модель в WinSock
</h1>
<p align="right">12.12.00</p>
<table width="60%" cellspacing="0" cellpadding="0" align="center" border="0">
<tr><td>
<h2>Автор</h2>
<font size="-1">

    <p align="justify">
      Автором этого текста является Gregory 
      Liokumovich (<a href="mailto:liokumovich@mail.ru">liokumovich@mail.ru</a>).
      Он любезно прислал мне этот текст, связанный с программированием сетей при
      помощи интерфейса WinSock, чему я лично очень рад: прежде всего потому,
      что сам имею очень мало опыта использования WinSock, а не упоминать
      о нем в разделе сетевого программирования совсем нехорошо. 
    </p>
    <p align="justify">
      Пользуясь случаем, хочу еще раз поблагодарить
      Григория за этот текст. Если я правильно понимаю, то он родился после
      предыдущей заметки, где рассказывалось о неблокирующем <code>connect</code>.
      Я обойдусь сейчас без комментариев к изложенной ниже точке зрения, но в ближайшее
      время хочу так же конструктивно рассказать о том, каким я себе
      представляю скелет сетевой программы.
    </p>
</font>
</td></tr></table>


 
    <p align="justify">
      Сразу оговорюсь, что поскольку я занимаюсь программированием под 
      Windows, то и говорить буду про реализацию сокетов под эту 
      платформу. WinSock позволяет работать с сокетами в рамках трех 
      подходов, против двух классических. А именно, обычная 
      блокирующая передача данных, неблокирующая передача 
      данных, событийно ориентированная передача данных. Лично я 
      предпочитаю третий, и ниже попытаюсь основные изложить причины. 
    </p>
    <h2>Немного вводной информации</h2>
    <p align="justify">
      Основные функции:
    </p>
    <ul>
      <li><code>WSACreateEvent()</code> --- создать новое событие;</li>
      <li><code>WSACloseEvent()</code> --- удалить событие;</li>
      <li><code>WSAEventSelect()</code> --- связать событие с сокетом и 
	его внутренним событием (пришли новые данные, готов к передаче и т.д.);
      </li>
      <li>
	<code>WSAWaitForMultipleEvents()</code> --- ожидание событий.
      </li>
    </ul>
    <p align="justify">
      Таким образом, алгоритм примерно такой: создаем сокет, создаем для 
      него событие, связываем, далее ожидаем от него событий и реагируем 
      на них. После того, как известно, что сокет готов к приему (передаче) 
      данных, я предпочитаю использовать блокирующие операции 
      чтения (отправки) данных. При этом, если например не 
      все данные будут прочитаны из буфера, соответствующее событие 
      будет автоматически активировано снова.
    </p>
    <p align="justify">
      Что интересно тип WSAEVENT является просто переопределением типа  HANDLE 
      со всеми вытекающими отсюда возможностями.
    </p>
    <h2>Причина первая, эстетическая</h2>
    <p align="justify">
      Общеизвестный факт, что все ПО развивается в сторону 
      унификации интерфейса, это позволяет значительно упростить 
      и ускорить его использование для пользователя. Вполне 
      логично, что унификация программного API приводит к более 
      эффективному и грамотному его использованию программистами, 
      которые выступают в роли потребителей API. Так вот, с этой 
      точки зрения событийный подход с известной всем windows программистам 
      функцией <code>WaitForMultipleObject</code> (пусть даже с каким-то 
      префиксом) явно упрощает использование сокетов.     
    </p>
    <p align="justify">
      Кроме того, лично мне следующий фрагмент кода
    </p>
<pre>
res = WSAWaitForMultipleObject(5,  Events, FALSE, WSA_INFINITE, FALSE);
if (res == WSA_WAIT_FAILED)    
{
    // . . .
}
index = res;
WSAEnumNetworkEvents(sockets[index],  Events[index], &amp;info)
if (info. lNetworkEvents &amp; FD_READ)
{
    // принимаем новые данные
}
</pre>
    <p class="table">
      кажется намного более понятным и приятным чем этот
    </p>
<pre>
int res = select(0, &amp;read, &amp;write, &amp;error, NULL)
if (res == SOCKET_ERROR)
{
    // . . .
}
for(int i = 0; i &lt; socket.size(); i++) 
{
     if (FD_ISSET(socket[i], &amp;read) )
        // принимаем данные
}
</pre>
    <p align="justify">
      Как видно и вышенаписанного в событийном подходе мы 
      исходим от события, мы знаем для какого сокета есть новости. 
      Во втором же случае, мы не знаем, что произошло и вынуждены 
      перебирать все варианты. В первом случае мы оперируем 
      массивами и событиями, во втором же случае неочевидными 
      структурами и макросами.
    </p>
    <h2>Причина вторая, элегантная</h2>
    <p align="justify">
      Используя <code>select</code> или <code>WSAWaitForMultipleEvents</code>  
      мы в любом случае не можем удалять или добавлять соединения во время 
      работы данных функций, так как это приведет к сбою. А это наверняка придется делать. 
    </p>
    <p align="justify">
      Если в программе, только один поток то проблемы нет, но не 
      надо забывать что обе эти функции поддерживают не более 64  сокетов. 
      А если надо больше? писать <code>select</code> за <code>select</code>'ом и
      ставить выход по 
      таймауту --- это очень некрасиво, но (что намного более важно) мы тут же 
      теряем скорости реакции или скатываемся до элементарного опроса
      готов/не готов. А если надо поддерживать 500 соединений? 
      Время  реакции будет ужасным. В связи с этим хочу также 
      отметить, что, по-моему, <code>WSAWaitForMultipleEvents</code> работает быстрее, 
      чем <code>select</code> в режиме опроса, но это субъективное мнение --- цифрами 
      подтвердить не могу. 
    </p>
    <p align="justify">
      Так вот, единственный разумный выход из описанной ситуации который мне 
      видится --- это многопоточность. Каждый поток работает со своими соединениями
      и все замечательно. Но тут возникает (как это всегда бывает 
      с потоками) проблемы взаимной синхронизации. 
    </p>
    <p align="justify">
      Предположим поток 1 хочет добавить сокет в обработчик потока 2. В это 
      время поток 2, выполняет <code>select</code> (или <code>WSAWaitForMultipleEvents</code>). 
      Что прикажете делать? Что делать в случае <code>select</code> я, честно говоря, даже не знаю. 
      При использовании событий я нашел, по-моему, неплохой и достаточно красивый 
      выход. Создается одно пустое событие, которое не привязано к конкретному сокету. 
      Это событие добавляется к остальным, которых дожидается <code>WSAWaitForMultipleEvents</code> 
      (при этом число сокетов на поток уменьшается до 63). И вот в тот самый 
      момент, когда мне надо вывести Поток два из "комотозного" состояния, я просто 
      активирую это событие и все. То есть я использую события от сокета вместе и наравне 
      с другими событиями. И отсюда вытекает еще одна более принципиальная причина.
    </p>
    <h2>Причина третья, принципиальная</h2>
    <p align="justify">
      Если задуматься  на тему что такое поступление новых данных 
      в сокет или, например, что такое закрытие сокета с другой 
      стороны. Можно придти к простому выводу --- это события. 
      Такие же события, как наступления времени Х или любое 
      другое событие в программе. Более того,  абсолютнозаконна 
      постановка вопроса: "ждем пока произойдет какое-нибудь 
      событие или пока придут данные от сокета". Поэтому это 
      правильно и логично, что и работа с сокетами 
      должна строится на событиях.
    </p>

<h2>Резюме</h2>
    <p align="justify">
      Вполне возможно, что для кого-то все вышесказанное не 
      является причиной, а опущенные здесь нюансы более весомы, но 
      лично я считаю, что использование событийной модели удобно, 
      элегантно, а иногда и просто спасительно.
    </p>




<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
