<html><head><title>ALK :: Сети :: Lingering close.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/network/29_10_00.shtml">http://www.kalinin.ru/programming/network/29_10_00.shtml</a><br>
<hr>
<br>

<h1>lingering close
</h1>
<p align="right">29.10.00</p>
 
    <p align="justify">
      Когда программа выкачивает один файл с удаленного сервера с использованием
      протокола TCP, а после этого сразу же "отваливается", то проблем, скорее всего,
      не возникнет никаких. Допустим, для определенности, что эта
      программа использует HTTP для передачи данных. В этом случае вся программа
      сводится к тому, что открывается сокет, указывается адрес удаленной машины и порт,
      туда передается, например, "GET /", после чего программа выкачивает все, что ей
      в этот сокет кинули. Это очень просто и каждый программист, даже
      никогда до этих пор не работавший с протоколами семейства TCP/IP, 
      прочитав содержимое man-страниц, сможет
      написать подобную программу. 
    </p>
    <p align="justify">
      Тем не менее, редко когда программа ограничивается выкачиванием
      одного лишь файла. Через некоторое время становится нужно
      выкачать с удаленной машины еще что-нибудь, потом обработать
      редиректы, потом еще кое-что появится... вы и оглянуться не успеете,
      как будете анализировать содержимое файла robots.txt. 
      Тем не менее, программа, которая выкачивает один файл, и программа,
      которая выкачивает несколько файлов, совсем не одно и то же. 
    </p>
    <p align="justify">
      Причины тому достаточно прозаические. Все дело в том, что программа,
      которая выкачивает один файл, потом другой и только потом третий, будет
      работать очень медленно. И это несмотря на скорость вашего канала: программа,
      которая работает по такой схеме, большую часть времени будет
      проводить в ожидании соединения или прихода данных.
    </p>
    <p align="justify">
      Поэтому ни веб-клиенты, ни веб-сервера обычно не строятся по схеме изложенной выше,
      а являются либо многопоточными программами, либо используют асинхронные или неблокирующие
      функции ввода-вывода, либо выбирают "готовые" дескрипторы из некоторого списка... в общем,
      вариантов много и я не буду сейчас их все расписывать. Достаточно понять то,
      что программа будет несколько сложнее чем ее первоначальный вариант и будет
      управляться событиями ввода-вывода от разных соединений, а не ожидать окончания
      одного. 
    </p>
    <p align="justify">
      И все хорошо до тех пор, пока количество файлов, подлежащих одновременному
      выкачиванию не становится очень большим, а пропускная способность вашего канала
      уже достаточно велика... как это произойдет, то через некоторое время, скорее всего, у вас
      вдруг перестанут открываться сокеты с ошибкой наподобие ENOBUF. 
    </p>
    <p align="justify">
      Происходит это потому, что в операционной системе имеется естественное ограничение
      на количество одновременно открытых сокетов. Связано это с тем, что на каждый сокет
      выделяется буфер, используемый для операций чтения и записи, который занимает некоторое
      место. Обычно этот буфер выделяется из некоторого пула и, хотя я не знаю как
      обстоит с ним дело в, например, Windows, но могу с некоторой долей уверенности
      сказать, что и там он не резиновый. В BSD, к примеру, его размер можно указать
      в конфигурации ядра. Тем не менее, количество открытых сокетов в вашей программе
      не будет велико, так в чем же дело?
    </p>
    <p align="justify">
      Ответ достаточно прост. То что вы вызвали функцию ядра <code>close()</code> на
      сокет, еще не означает, что сразу же будут освобождены все структуры, с ним связанные.
      Это, всего-лищь означает, что этот сокет больше не будет доступен
      вашей программе, а ядро еще некоторое время будет удерживать его в состоянии вроде
      <code>TIME_WAIT</code>. Время между вызовом <code>close()</code> и 
      реальным освобождением сокета расчитывается исходя из максимального времени
      существования пакета в сети. 
    </p>
    <p align="justify">
      Существуют два решения этой проблемы. Первое заключается в увеличении количества
      памяти, выделяемой операционной системой под сокеты. Второе --- в использовании
      того, что в англоязычной литературе называется "lingering close". 
    </p>
    <p align="justify">
      Существует атрибут у сокета, называемый <code>SO_LINGER</code>. При его помощи
      можно изменить поведение <code>close()</code> на такое, при котором вызывающий
      процесс будет переведен в состояние ожидания реального закрытия сокета. Выставив
      этот атрибут, вам потребуется также указать время ожидания для данного сокета. 
      Второе решение рассматриваемой проблемы заключается в том, что бы "включить" <code>SO_LINGER</code>
      для сокетов и установить время ожидания в 0. В этом случае все
      структуры, связанные с сокетами, будут освобождены сразу. Делается это
      следующим образом:
    </p>
<pre>
struct linger l = { 1, 0 };
setsockopt(sock, SOL_SOCKET, SO_LINGER, &amp;l, sizeof(struct linger));
close(sock);
</pre>
    <p align="justify">
      Тем не менее, "второе решение" чревато новыми проблемами: через некоторое
      время вы обнаружите странные ситуации обрыва связи с удаленной машиной при
      одновременном выкачивании с нее нескольких файлов (в случае одного файла
      все будет в порядке).
    <p align="justify">
      Тут 
      надо четко понимать, откуда взялось время между вызовом <code>close()</code> и реальным
      освобождением сокета. Все дело в том, что пакеты в сети не идут напрямую от одного 
      адреса к другому, а "блуждают" по сети в поисках своего адресата. При использовании
      TCP, пакеты характеризуются четырьмя параметрами: IP-адресом отправителя, портом отправителя,
      IP-адресом получателя и портом получателя. Поэтому, если закрыть сокет сразу,
      а потом случайно открыть соединение с той же удаленной машиной по тому же локальному
      порту, то пакеты от старого соединения, которые все еще "блуждают", будут восприняты
      как реальные данные нового соединения! В частности, очень просто получить потверждающий
      FIN, который пришел в качестве реакции на предыдущий <code>close()</code>, в результате
      которого произойдет разрыв соединения. 
    </p>
    <p align="justify">
      И еще раз. При повторном HTTP запросе на сервер у вас три из четырех параметров в TCP пакете
      будут точно такими же, как и при первом HTTP запросе, то есть IP-адреса компьютеров и 
      порт сервера (80). Вероятность же того, что на локальной машине вы получите тот же порт,
      что и в предыдущий раз, не нулевая и вполне реальная. Таким образом, данные могут быть
      повреждены. 
    </p>
    <p align="justify">
      Существует еще одно объяснение появления времени между вызовом <code>close()</code> 
      и освобождением структур, связанных с сокетами, которое, правда, не имеет
      прямого отношения к рассматриваемой гипотетической программе. Все дело в том, что 
      при записи в сокет, вызов <code>close()</code> может последовать до того, как данные
      будут реально переданы на удаленную машину. В этом случае, реализация TCP должна
      будет "подождать" потверждение о приеме данных удаленной машиной. 
    </p>
    <p align="justify">
      Таким образом, возвращаясь к проблеме с сокетами в состоянии <code>TIME_WAIT</code>.
      Самым правильным будет увеличить размер памяти под сокеты: в этом случае
      работа вашей программы сразу же станет более стабильной. Lingering close можно
      применять только в том случае, когда вы уверены в том, что больше соединений
      с удаленной машиной по данному IP-адресу или порту не будет. Тогда это допустимо. 
      Иначе --- надо подождать.
    </p>
    <p align="justify">
      Время же ожидания, как я уже сказал выше, расчитывается исходя из максимального
      времени жизни пакета. Реально это время составляет несколько минут и зависит от 
      конкретной реализации TCP.
    </p>

<h2>Резюме</h2>
    <p align="justify">
      Lingering close с нулевым временем ожидания можно применять только в тех случаях, когда
      доподлинно известно, что "блуждающие" пакеты ничем больше повредить не могут.
    </p>



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td>Stevens</td>
<td width="100%">
     Network programming, volume 1.
</td></tr>
<tr><td>А. Робачевский.   </td>
<td width="100%">
     Операционная система Unix.
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
