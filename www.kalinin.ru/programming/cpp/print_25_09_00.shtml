<html><head><title>ALK :: C&amp;C++ :: Шаманство, или ошибки работы с памятью.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/25_09_00.shtml">http://www.kalinin.ru/programming/cpp/25_09_00.shtml</a><br>
<hr>
<br>

<h1>Шаманство, или ошибки работы с памятью
</h1>
<p align="right">25.09.00</p>
 
    <p align="justify">
      Когда программа становится внушительной по своему содержанию
      (то есть, не по количеству строчек, а по непонятности внутренних
      связей), то ее поведение становится похожим
      на поведение настоящего живого существа. Такое
      же непредсказуемое... впрочем, кое что все-таки предсказать
      можно: работать оно не будет. Во всяком случае, сразу.
    </p>
    <p align="justify">
      Программирование на C и C++ дает возможность
      допускать такие ошибки, поиск которых 
      озадачил бы самого Шерлока Холмса. Вообще говоря,
      чем загадочнее ведет себя программа, тем проще
      в ней допущена ошибка.
      А искать простые ошибки сложнее всего, как 
      это ни странно; все потому, что сложная ошибка
      обычно приводит к каким-то принципиальным
      неточностям в работе программы, а ошибка простая
      либо превращает всю работу в бред пьяного программиста,
      либо всегда приводит к одному и тому же: segmentation fault.
    </p>
    <p align="justify">
      И зря говорят, что если ваша программа выдала фразу
      core dumped, то ошибку найти очень просто: это, мол, всего лишь
      обращение по неверному указателю, например, нулевому. Обращение-то,
      конечно же, есть, но вот почему в указателе появилось неверное
      значение? Откуда оно взялось? Зачастую на этот вопрос
      не так просто ответить.
    </p>
    <p align="justify">
      В Java исключены указатели именно потому, что работа с ними
      является основным источником ошибок программистов. При этом
      отсутствие инициализации является одним из самых простых
      и легко отлавливаемых вариантов ошибок.
    </p>
    <p align="justify">
      Самые трудные ошибки пояляются, по-моему, тогда, когда
      в программе постоянно идут процессы выделения и удаления
      памяти. То есть, в короткие промежутки времени
      появляются объекты и уничтожаются. В этом случае,
      если где-нибудь что-нибудь некорректно "указать",
      то "core dumped", вполне вероятно, появится не сразу,
      а лишь через некоторое время. Все дело в том, что 
      ошибки с указателями проявляются обычно в двух случаях:
      работа с несуществующим указателем и выход за пределы 
      массива (тоже в конечном итоге сводится к несуществующему
      указателю, но несколько чаще встречается).
    </p>
    <p align="justify">
      Я уже писал о том, что загадки, возникающие при удалении
      незанятой памяти, одни из самых трудных. Выход за границы
      массива, пожалуй, еще сложнее. 
    </p>
    <p align="justify">
      Представьте себе: вы выделили некоторый буфер и в него
      что-то записываете, какие-то промежуточные данные. Это
      критическое по времени место, поэтому тут быть
      не может никаких проверок и, ко всему прочему,
      вы уверены в том, что исходного размера буфера хватит
      на все, что в него будут писать. Лично я бы не хотел
      торопиться с подобными утвержденияями: а почему,
      собественно, вы так в этом уверены? И вообще, а вы
      уверены в том, что правильно вычиcлили этот самый размер
      буфера?
    </p>
    <p align="justify">
      Ответы на эти вопросы должны у вас быть. Мало того,
      они должны находиться в комментариях рядом с 
      вычислением размера буфера и его заполнением,
      что бы потом не гадать, чем руководствовался
      автор, когда написал 
    </p>
<pre>
char buf[100];
</pre>
    <p align="justify">
      Что он хотел сказать? Откуда взялось число 100? Совершенно непонятно.
    </p>
    <p align="justify">
      Теперь о том, почему важно не ошибиться с размерами. Представьте
      себе, что вы вышли за пределы массива. Там может
      "ничего не быть", т.е. этот адрес не принадлежит программе
      и тогда в нормальной операционной системе вы получите соответствующее
      "матерное" выражение. А если там что-то было?
    </p>
    <p align="justify">
      Самый простой случай --- если там были просто данные. Например,
      какое-нибудь число. Тогда ошибка, по крайней мере, будет видна
      почти сразу... а если там находился другой указатель? Тогда
      у вас получается наведенная ошибка очень высокой сложности. Потому
      что вы будете очень долго искать то место, где вы забыли
      нужным образом проинициализировать этот указатель...
    </p>
    <p align="justify">
      Мало того, подобные "наведенные" ошибки вполне могут
      вести себя по-разному не только на разных тестах, но и на одинаковых.
    </p>
    <p align="justify">
      А если еще программа "кормится" данными, которые поступают непрерывно...
      и еще она сделана таким образом, что реагирует на события, которые
      каким-то образом распределяются циклом обработки событий... тогда
      все будет совсем плохо. Отлаживать подобные программы очень сложно,
      тем более что, зачастую, для того, что бы получить замеченную
      ошибку повторно, может потребоваться несколько часов выполнения программы.
      И что делать в этих случаях?
    </p>
    <p align="justify">
      Поиск таких ошибок более всего напоминает
      шаманские пляски с бубном около костра, не зря
      этот образ появился в программистком жаргоне. Потому
      что программист, измученный бдениями, начинает
      просто случайным образом "удалять" (закомментировав некоторую область,
      или набрав <code>#if 0 ... #endif</code>) блоки своей программы, что бы 
      посмотреть, в каком случае оно будет работать, а в каком --- нет.
    </p>
    <p align="justify">
      Это действительно напоминает шаманство, потому что 
      иногда программист уже не верит в то, что, например, 
      "от перестановки мест сумма слагаемых не меняется" и
      запросто может попытаться переставить  и проверить
      результат... авось? 
    </p>
    <p align="justify">
      А вот теперь я подобрался к тому, о чем хотел
      сказать. В шаманстве тоже можно выделить систему.
      Для этого достаточно осознать, что большинсто 
      загадочных ошибок происходят именно из-за
      манипуляций с указателями. Поэтому, вместо
      того что бы переставлять местами
      строчки программы, можно просто 
      попытаться для начала закомментировать
      в некоторых особенно опасных местах
      удаление выделенной памяти и посмотреть что
      получится.
    </p>	
    <p align="justify">
      Кстати сказать, отладка таких моментов
      требует (именно требует) наличия отладочной
      информации во всех используемых библиотеках,
      так будет легче работать. Так что, если
      есть возможность скомпилировать библиотеку
      с отладочной информацией, то так и надо делать ---
      от лишнего можно будет избавиться потом.
    </p>
    <p align="justify">
      Если загадки остались, то надо двинуться дальше и проверить
      индексацию массивов на корректность. В идеале,
      перед каждым обращением к массиву
      должна находиться проверка инварианта относительно
      того, что индекс находиться в допустимых пределах. Такие
      проверки надо делать отключаемыми при помощи макросов
      DEBUG/RELEASE с тем, что бы в окончательной
      версии эти дополнительные проверки не мешались бы (этим,
      в конце-концов, C отличается от Java: хотим --- проверяем,
      не хотим --- не проверяем). В этом случае
      вы значительно быстрее сможете найти глупую
      ошибку (а ошибки вообще не бывают умными; но найденные --- глупее
      оставшихся ;) ).
    </p>
    <p align="justify">
      На самом деле, в C++ очень удобно использовать
      для подобных проверок шаблонные типы данных. То есть,
      сделать тип "массив", в котром переопределить
      необходимые операции, снабдив каждую из них
      нужными проверками. Операции реализовать как <code>inline</code>,
      это позволит не потерять эффективность работы программы. В то же
      самое время, очень легко будет удалить все 
      отладочные проверки или вставить новые. В общем,
      реализация своего собственного типа данных <code>Buffer</code>
      является очень полезной.
    </p>
    <p align="justify">
      Кстати, раз уж зашла об этом речь, то абзац выше 
      является еще одним свидетельством того, что C++ надо
      использовать "полностью" и никогда не писать на нем
      как на "усовершенствованном C". Если вы предпочитаете
      писать на C, то именно его и надо использовать. При помощи
      C++ те же задачи решаются совсем по другому.
    </p>

<h2>Резюме</h2>
    <p align="justify">
      Ошибки допускают все и бессонные ночи бывают у каждого
      программиста. Самое страшное заключается в том, что
      когда ошибка найдена, то всегда появляется ощущение 
      зря потерянного времени... вообще говоря, любой
      опыт, если он не прошел даром, положителен. То есть,
      это значит, что в следующий раз, возможно, подобную
      ошибку вы будете искать не так долго.
    </p>
    <p align="justify">
      Хотя, конечно же, лучше всего ошибок не допускать вообще.
      А вот как это сделать?
    </p>	



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td>Бъерн Страуструп</td>
<td width="100%">
     Язык программирования C++, 3 издание. 
</td></tr>
<tr><td><a href="/comment/books/16_08_00.shtml">/comment/books/16_08_00.shtml</a></td>
<td width="100%">
     C++: библиотека программиста.
</td></tr>
<tr><td><a href="/comment/books/27_08_00.html">/comment/books/27_08_00.html</a></td>
<td width="100%">
     C и C++. Правила программирования.
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
