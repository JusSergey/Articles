<html><head><title>ALK :: C&amp;C++ :: Библиотека STLport 4.0.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/20_07_00.shtml">http://www.kalinin.ru/programming/cpp/20_07_00.shtml</a><br>
<hr>
<br>

<h1>STLport 4.0
</h1>
<p align="right">20.07.00</p>
 
    <p align="justify">
      14 июля 2000 года наконец-то вышла новая версия библиотеки 
      <a href="http://www.stlport.org">STLport</a> 4.0. 
      Для тех, кто еще не в курсе, что это такое, объясняю: это 
      свободно распространяемая реализация стандартной библиотеки шаблонов
      для множества различных компиляторов и операционных систем.
      Кроме всего прочего, STLport дотсупен не только для современных
      компиляторов, более или менее удовлетворяющих стандарту языка, но
      и для некоторых старых компляторов, например Borland C++ 5.02
      или MS Visual C++ 4.0.
    </p>
    <p align="justify">
      Четвертая версия STLport отличается от предыдущей прежде всего
      тем, что теперь в нее входит полная поддержка
      потоков (ранее приходилось использовать потоки из
      библиотеки, поставляемой с конкретным компилятором). Реализация
      потоков взята из SGI (как, впрочем, и весь STLport). Вообще,
      STLport начал развиваться как попытка Бориса Фомичева
      перенести ивзестную библиотеку SGI STL на gcc и sun cc.
      Таким образом, с выходом четвертой версии, STLport стал
      полноценной библиотекой, соответствующей стандарту языка,
      во всяком случае, у него появились претензии на это.
    </p>
    <p align="justify">
      Понятно, что использование одной и той же библиотеки
      на разных платформах, это уже большой плюс --- потому
      что никогда точно заранее не известно, что где и как 
      будет плохо себя вести. Можно лишь гарантировать, что 
      программа, при переносе с одного компилятора на другой, 
      все-таки будет себя плохо вести даже в том случае, если скомпилируется.
      Использование одной библиотеки шаблонов очень сильно повышает
      шансы на то, что не будет крепкого мата тогда, когда
      программист увидит отсутствие в STL нового компилятора
      какого-нибудь контейнера. Например, в g++-stl-3 нет
      <code>std::wstring</code>. То есть, шаблон
      <code>std::basic_string</code> есть, и <code>std::string</code>
      является его инстанционированием на <code>char</code>,
      но попытка подставить туда же <code>wchar_t</code> ни к чему
      хорошему не приведет (в частности, из-за того, что в методе 
      <code>c_str()</code> есть замечательная строчка вида
      <code>return ""</code>). 
    </p>
    <p align="justify">
      Но и кроме единых исходных текстов у STLport есть еще несколько
      интересных возможностей и особенностей. Во-первых, это
      debug mode, при котором проверяются все условия, которые
      только возможны. Например, в этом режиме при попытке работать
      с неинициализированным итератором будет выдано соответствующее
      ругательство. Согласитесь, это удобно.
    </p>
    <p align="justify">
      Во-вторых, в STLport есть несколько нестандартных контейнеров, таких
      как <code>hash_map</code>, например. Зачем? Ну, потому что стандартный
      <code>map</code> обычно реализован на сбалансированных деревьях 
      поиска (как более общий способ обеспечения быстрого поиска при разнородных данных),
      и что делать в том случае, когда все-таки известна хорошая хеш-функция для
      конкретных элементов,
      не особенно понятно (ну, кроме того, что бы написать подобный
      контейнер самостоятельно).
    </p>
    <p align="justify">
      В третьих, поддержка многопоточности. То есть, STLport можно безопасно
      использовать в программах, у которых более одного потока выполнения.
      Это досталось STLport еще от SGI STL, в которой очень много внимания
      уделялось именно безопасности использования.
    </p>

<h2>Резюме</h2>
    <p align="justify">
      STLport является той библиотекой, которую я в последнее время стараюсь
      использовать где только можно. А для g++ на win32 так и вообще постоянно.
      Поэтому я был очень рад тому, что в 4-ой версии появилась поддержка
      mingw32.
    </p>
    <p align="justify">
      Так что, если вдруг появились какие-то проблемы с STL,
      то можно попробовать взять STLport --- быть может, проблем станет поменьше.
    </p>



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td><a href="http://www.stlport.org" target="_blank">http://www.stlport.org</a></td>
<td width="100%">
     Официальный сайт библиотеки STLport. 
</td></tr>
<tr><td><a href="http://www.sgi.com/Technology/STL/" target="_blank">http://www.sgi.com/Technology/</a></td>
<td width="100%">
     Страничка библиотеки SGI STL.
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
