<html><head><title>ALK :: C&amp;C++ :: Модификатор volatile.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/12_09_00.shtml">http://www.kalinin.ru/programming/cpp/12_09_00.shtml</a><br>
<hr>
<br>

<h1>volatile
</h1>
<p align="right">12.09.00</p>
<table width="60%" cellspacing="0" cellpadding="0" align="center" border="0">
<tr><td>
<h2>Автор</h2>
<font size="-1">

    <p align="justify">
      И опять я публикую здесь текст из конференции SU.C_CPP. Впору заводить
      для этого отдельный раздел ;)
    </p>
    <p align="justify">
      Автор этого письма, Александр Кротов, является человеком,
      который умеет цитировать стандарт языка C++. Это, кстати, очень
      сложно: ведь нужно помнить что и где находится, что бы при
      ответе на вопрос сразу же дать нужный пункт стандарта. Собственно, цитируемое
      ниже письмо, как мне кажется, может предоставлять некоторый интерес со стороны
      программистов на C++. Опять же, делаю автору (Александру) всевозможные реверансы и 
      прошу всяческих прощений за использование его письма в своем разделе. Еще раз повторяю ---
      автор текста ниже не я, а Александр Кротов (давать его почтовый адрес не хочу, потому
      что на меня уже сыпется спам и, я уверен, на любой почтовый адрес упомянутый на страничке,
      он тоже будет сыпаться; интересующееся адресом Александра, могут спросить у меня).
      Письмо датировано 21 апрелем 1999 года.
    </p>
</font>
</td></tr></table>


 
    <p class="question">
      Hапример, в тех
      случаях, когда x объявлен с модификатором <code>volatile</code> (насколько я понимаю,
      <code>volatile</code> lvalue должен быть физически "взят" вне зависимости от того, с какой
      стороны от знака операции присваивания он находится; первая запись в этом
      случае просто не будет иметь определенного смысла, я думаю).
    </p>
    <p align="justify">
      А вот пример мне не нравится. Обычно под побочными эффектами подразумевают
      нечто иное.
    </p>
    <p align="justify">
      И насчет <code>volatile</code> тут ты тоже не совсем прав. Точное значение <code>volatile</code>
      по стандарту зависит от компилятора, по этому есть смысл говорить только о
      том, что компиляторы "как правило" делают с <code>volatile</code> переменными.
      Hапример есть целый класс оптимизаций связанных с value numbering.
      Оптимизации из этого класса позволяют, например, выделять общеие подвыражения
      (local/global common subexpressions), выносить из цикла инвариантные
      вычисления, а то и совмещать эти две приятные процедуры (partial redundancy
      elimination, например популярный сейча lazy code motion aka LCM).
      Для всех этих оптимизаций уже придуманы хорошие формальные модели, которые,
      в свою очередь, уже много где описаны ;-) Так что есть смысл ожидать того,
      что в том компиляторе, которым ты пользуешься они хотя-бы частично
      реализованы.
    </p>
    <p align="justify">
      Так вот, к чему я это все. Как правило <code>volatile</code> отражается именно на
      таких оптимизациях. (В формализмах учесть этот самый <code>volatile</code>
      очень легко).
    </p>
    <p align="justify">
      В твоем примере
    </p>
<pre>
	volatile int x;
	x = x^n;
</pre>
	    <p class="table">
	      или
	    </p>
<pre>
	x ^= n;
</pre>
    <p class="table">
      особой разницы нет. В первом случае значение x прочитано и тутже
      перезаписано. Очень грубо чтение и запись можно считать атомарными.
      Во втором случае имеем (столь же грубо) одну атомарную операцию.
      Здесь то, что <code>x</code> - <code>volatile</code> на результате не может отразиться.
    </p>
    <p align="justify">
      Примеры, где <code>volatile</code> может сыграть:
    </p>
<pre>
	int a, b, c, d;
	...
	c = x+a+b;
	... // код не меняющий ни x, ни a 
	d = x+a;
</pre>
    <p class="table">
      Здесь <code>(x+a)</code> - общее подвыражение, и если <code>x</code> - <code>volatile</code>, то компилятор
      скорее всего не будет его оптимизировать.
    </p>
    <p align="justify">
      Другой пример
    </p>
<pre>
	while (x<5) {
		// что-то не меняющее x
	};
</pre>
    <p align="justify">
      Здесь очевидно, что условие цикла, не будь <code>x</code> - <code>volatile,</code> не
      меняется. То есть его можно соптимизировать вынеся лишние вычисления
      из цикла
    </p>
<pre>
	if (x<5)
		while(1) {
			// ....
		}
</pre>
    <p align="justify">
      Если же <code>x</code> - <code>volatile</code> компилятор скорее всего такой оптимизации делать
      не будет.




<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td>Бъерн Страуструп</td>
<td width="100%">
       Язык программирования C++, 3 издание. 
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
