<html><head><title>ALK :: C&amp;C++ :: Функция gets().</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/15_08_00.shtml">http://www.kalinin.ru/programming/cpp/15_08_00.shtml</a><br>
<hr>
<br>

<h1>Функция gets()
</h1>
<p align="right">15.08.00</p>
 
    <p align="justify">
      Функция gets(), входящая в состав стандартной библиотеки C, имеет следующий
      прототип:
    </p>
<pre>
char* gets(char* s);
</pre>
    <p class="table">
      Это определение содержится в <code>stdio.h</code>. Функция предназначена
      для ввода строки символов из файла <code>stdin</code>. Она возвращает
      <code>s</code> если чтение прошло успешно и <code>NULL</code>
      в обратном случае.
    </p>
    <p align="justify">
      При всей простоте и понятности, эта функция уникальна. Все дело
      в том, что более опасного вызова, чем этот, в стандартной
      библиотеке нет... почему это так, а также чем грозит использование
      gets(),  я как раз и попытаюсь
      объяснить в сегодняшней заметке.
    </p>
    <p align="justify">
      Вообще говоря, для тех, кто не знает, почему использование 
      функции <code>gets()</code> так опасно,
      будет полезно посмотреть еще раз на ее прототип, и подумать. Если
      догадаетесь самостоятельно, будет лишний повод немного погордиться ;)
    </p>
    <p align="justify">
      Все дело в том, что для <code>gets()</code> нельзя, т.е.
      совершенно невозможно, задать ограничение на размер читаемой
      строки, во всяком случае, в пределах стандартной библиотеки. Это
      крайне опасно, потому что тогда при работе с вашей программой
      могут возникать различные сбои при обычном вводе строк пользователями.
      Т.е., например:
    </p>
<pre>
char name[10];

// ...

puts("Enter you name:");
gets(name);
</pre>
    <p class="table">
      Если у пользователя будет имя больше, чем 9 символов, например, 10,
      то по адресу <code>(name + 10)</code> будет записан 0. Что там на
      самом деле находится, другие данные или просто незанятое место
      (возникшее, например, из-за того, что компилятор соответствующим
      образом выравнял данные), или этот адрес для программы недоступен,
      неизвестно.
    </p>
    <p align="justify">
      Все эти ситуации ничего хорошего не сулят. Порча собственных
      данных означает то, что программа выдаст 
      неверные результаты, а почему это происходит
      понять будет крайне трудно --- первым делом программист
      будет проверять ошибки в алгоритме и только в конце заметит, 
      что произошло переполнение внутреннего буфера. Я думаю, все 
      знают как это происходит --- несколько часов непрерывных
      "бдений" с отладчиком, а потом через день, "на свежую голову",
      выясняется что где-то был пропущен один символ...
    </p>
    <p align="justify">
      Опять же, для программиста самым удобным будет моментальное 
      аварийное прекращение работы программы в этом месте --- тогда
      он сможет заменить <code>gets()</code> на что-нибудь 
      более "порядочное".
    </p>
    <p align="justify">
      У кого-то может возникнуть предложение просто взять и увеличить
      размер буфера. Но не надо забывать, что всегда можно ввести строку 
      длиной, превышающий выделенный размер; если кто-то хочет возразить,
      что случаи имен длиной более чем, например, 1024 байта все еще редки,
      то я перейду к другому, несколько более интересному примеру возникающей
      проблемы при использовании
      <code>gets()</code>. 
    </p>
    <p align="justify">
      Для это просто подчеркну  контекст, в котором происходит чтение строки.
    </p>
<pre>
void foo()
{
  char name[10];

  // ...

  puts("Enter you name:");
  gets(name);

  // ...
}
</pre>
    <p class="table">
      Я имею в виду, что теперь <code>name</code> расположен в стеке. Надеюсь,
      что читающие эти строки люди имеют представление о том, как обычно
      выполняется вызов функции. Грубо говоря, сначала в стек помещается
      адрес возврата, а потом в нем же размещается память под массив <code>name</code>.
      Так что теперь, когда функция <code>gets()</code> будет писать за пределами массива,
      она будет портить адрес возврата из функции <code>foo()</code>.
    </p>
    <p align="justify">
      На самом деле, это значит, что кто-то может задать вашей программе
      любой адрес, по которому она начнет выполнять инструкции. 
    </p>
    <p align="justify">
      Немного отвлечемся, потому что это достаточно интересно. 
      В операционной системе Unix есть возможность запускать программы,
      которые будут иметь привилегии пользователя, отличного от того,
      кто этот запуск произвел. Самый распространенный пример, это, конечно же,
      суперпользователь. Например, команды <code>ps</code> или <code>passwd</code>
      при запуске любым пользователем получают полномочия root'а. Сделано это
      потому, что копаться в чужой памяти (для <code>ps</code>) может
      только суперпользователь, так же как и вносить изменения в <code>/etc/passwd</code>.
      Понятно, что такие программы тщательнейшим образом проверяются на отсутствие
      ошибок --- через них могут "утечь" полномочия
      к нехорошим "хакерам" (существуют и хорошие ;) ). Размещение буфера в стеке некоторой
      функции, чей код выполняется с привилегиями другого пользователя, позволяет при переполнении 
      этого буфера изменить на что-то осмысленное адрес возврата из функции. 
      Как поместить по переданному адресу то, что требуется выполнить (например,
      запуск командного интерпретатора), это уже другой разговор и он
      не имеет прямого отношения к программированию на C или C++.
    </p>
    <p align="justify">
      Принципиально иное: отсутствие проверки на переполнение внутренних 
      буферов очень серьезная проблема. Зачастую программисты ее
      игнорируют, считая что некоторого заданного размера хватит на все,
      но это не так. Лучше с самого начала позаботиться о необходимых
      проверках, что бы потом не мучаться с решением внезапно
      возникающих проблем. Даже если вы не будете писать программ, к которым
      выдвигаются повышенные требования по устойчивости к взлому, все равно
      будет приятно осознавать, что некоторых неприятностей возможно удалось избежать.
      А от <code>gets()</code> избавиться совсем просто:
    </p>
<pre>
fgets(name, 10, stdin);
</pre>

<h2>Резюме</h2>
    <p align="justify">
      Использование функции <code>gets()</code> дает лишнюю возможность
      сбоя вашей программы, поэтому ее использование крайне не рекомендовано.
      Обычно вызов <code>gets()</code> с успехом заменяется <code>fgets()</code>.
    </p>



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td>Бъерн Страуструп</td>
<td width="100%">
     Язык программирования C++, 3 издание. 
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
