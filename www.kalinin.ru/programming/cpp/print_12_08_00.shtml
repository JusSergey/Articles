<html><head><title>ALK :: C&amp;C++ :: Виртуальный конструктор.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/12_08_00.shtml">http://www.kalinin.ru/programming/cpp/12_08_00.shtml</a><br>
<hr>
<br>

<h1>Виртуальный конструктор
</h1>
<p align="right">12.08.00</p>
<table width="60%" cellspacing="0" cellpadding="0" align="center" border="0">
<tr><td>
<h2>Автор</h2>
<font size="-1">

    <p align="justify">
      Перелистывая архив сообщений из конференции SU.C_CPP, натолкнулся
      на любопытное письмо, которое решил поместить к себе на страничку.
      Автор --- опять Alexander V. Naumochkin (другое его интересное
      письмо находится <a href="17_07_00.shtml">здесь</a>). Повторю,
      что, к сожалению,
      знаю только его адрес в сети FIDO, 2:5020/59. Опять же, 
      я руководствовался тем, что больше нигде на страницах в интернете
      ничего на подобную тему я не видел, так что совершенно не понимаю, почему
      это письмо должно пропадать в моих архивах. Еще раз повторю, 
      что, надеюсь, Александр на меня за публикацию уже второго его письма (на этот раз
      оно датировано 3-м сентября 1998 года) не обидится.
    </p>
    <p align="justify">
      Все это можно рассматривать как прекрасный пример очень классного (в прямом и переносном
      смыслах ;) ) подхода к программированию на C++.
    </p>
</font>
</td></tr></table>


 
    <p align="justify">
      То, что обещал. Сначала то, что обычно помещают в конце :)  Месяц назад мне 
      дали почитать книгу, в которой любой (нежелающий пристально исследовать 
      нижеследующее) найдёт ответ на вопрос "А как это работает?"  Книга оказалась 
      на удивление старой, и я (хоть и сильно радовался ей) испытал некоторые 
      досадные чувства и всякие сожаления по поводу того, что не было её у меня чуть 
      больше года назад -- не пришлось бы всё это изобретать, ибо приведённое в 
      книге практически не отличается от "изобретённого". Книга называется 
      "Adavanced C++ Programming Styles and Idioms", автор James O. Coplien. Хотя 
      она уже не совсем соответсвует нынешнему состоянию C++, но ценность её 
      неоспорима, а уж для меня, утомлённого вышеупомянутым вопросом от французских 
      и немецких коллег, она ценна вдвойне -- я теперь им просто отсылаю ISBN и 
      номер страницы :)
    </p>
    <p align="justify">
      За её отсутствием (у нас, а не в природе :) при "изобретении" активно 
      использовались материалы из книг Страуструпа и Кнута. Глубоко интересующихся 
      некоторыми частностями "изобретения" отсылаю к этим авторам (благо они 
      доступны довольно легко).
    </p>
    <p align="justify">
      Предупреждение: то, что описано -- не совсем уж обычные объекты. Возможно 
      только динамическое их создание и только в отведённой уже памяти. Hи о каком 
      статическом или автоматическом их создании не может быть и речи. Это не цель и 
      не побочный эффект, это расплата за иные удобства.
    </p>
    <p align="justify">
      Краткое описание конкретной ситуации, где всё это и происходило. В некотором 
      исследовательском центре есть биохимическая лаборатория. Есть в ней куча 
      соответствующих анализаторов. Железки они умные, работают самостоятельно, лишь 
      бы сунули кассету с кучей материалов и заданиями. Всякий анализатор 
      обрабатывает материалы только определённой группы. Со всех них результаты 
      текут по одному шлангу в центр всяческих обработок и складирования. Масса 
      частностей, но нам они неинтересны. Суть -- _всякий_ результат есть результат 
      биохимического анализа. Текущий потоком байт с соответсвующими заголовками и 
      всякими телами. Конкретный тип реально выяснить из первых шестнадцати байт. 
      Максимальный размер -- есть. Hо он лишь максимальный, а не единственно 
      возможный.
    </p>
    <p align="justify">
      Hе вдаваясь в подробности принятого решения (это вынудит вдаваться в 
      подробности задания), возникла конкретная задача при реализации -- уже во 
      время исполнения конструктора объекта конкретный тип результата анализа 
      неизвестен. Hеизвестен (соответственно) и его размер. Известен лишь размер 
      пула для хранения некоторого количества этих объектов. Две проблемы -- 
      сконструировать объект конкретного типа в конструкторе объекта другого 
      (обобщающего) типа и положить его на это же самое место в памяти. При этом 
      память должно использовать эффективно, всячески минимизируя (главная проблема) 
      фрагментацию пула, ибо предсказать время, в течение которого результат будет 
      оставаться нужным (в ожидании, в частности, своих попутчиков от других 
      анализаторов), невозможно. Это -- не очередь (иначе всё было бы значительно 
      проще).
    </p>
    <p align="justify">
      Решение: от классической идиомы envelope/letter (которая сама по себе основа 
      кучи идиом) к "виртуальному" конструктору с особым (либо входящим в состав, 
      либо находящимся в дружеских отношениях) менеджером памяти. Излагается на 
      смеси C++ и недомолвок (некритичных) в виде '. . .'
    </p>
<pre>
class BCAR {    // Bio-Chemical Analysis Result

friend class BCAR_MemMgr;

protected:
    BCAR() { /* Должно быть пусто!!! */ }

public:
    BCAR( const unsigned char * );
    void *operator new( size_t );
    void operator delete( void * );
    virtual int size() { return 0; }
    . . .

private:
    struct {
        // трали-вали
    } header;
    . . .
};
</pre>
    <p align="justify">
      Это был базовый класс для всех прочих конкретных результатов анализов. У него 
      есть свой new, но это не тот, что я уже помянул в письме Хемулю. Hо я же ему и 
      сказал, что не дефолтовый new из C++ rtl используется для реализации идеи. А 
      используется следующее:
    </p>
<pre>
inline void *operator new( size_t, BCAR *p ) {
    return p;
}
</pre>
    <p align="justify">
      Именно за счёт его мы получим in place замену объекта одного класса (базового) 
      объектом другого (производного). Раньше было проще -- this допускал 
      присваивание. Подробности в "виртуальном конструкторе".
    </p>
    <p align="justify">
      Теперь -- менеджер памяти.
    </p>
<pre>
class BCAR_MemMgr {

friend BCAR;

public:
    BCAR_MemMgr();
    void alloc( int );
    void free( BCAR *, int );
    BCAR *largest();

private:
    . . .
};
</pre>
    <p align="justify">
      Это примерный его вид. Он создаётся в единственном экземпляре:
    </p>
<pre>
static BCAR_MemMgr MemoryManager;
</pre>
    <p class="table">
      и занимается обслугой пула памяти под все объекты. В открытом интерфейсе у 
      него всего три функции, назначение <code>alloc</code>/<code>free</code> любому понятно (хотя <code>alloc</code> в 
      действительности ничего не аллоцирует, а делает "обрезание" того, что даёт 
      <code>largest</code> и соответствующим образом правит списки менеджера), а <code>largest</code>
      возвращает указатель на самый большой свободный блок. В сущности, она и есть 
      <code>BCAR::new</code>, которая выглядит так:
    </p>
<pre>
void *BCAR::operator new( size_t ) {
    return MemoryManager.largest();
}
</pre>
    <p align="justify">
      Зачем самый большой? А затем, что при создании объекта его точный тип ещё 
      неизвестен (ибо создаваться будет через <code>new BCAR</code>), поэтому берём по максимуму, 
      а потом alloc всё подправит.
    </p>
    <p align="justify">
      Теперь собственно классы для конкретных результатов. Все они выглядят примерно 
      одинаково:
    </p>
<pre>
class Phlegm: public BCAR {

friend BCAR;

private:
    int size() { retrurn sizeof( Phlegm ); }
    struct PhlegmAnalysisBody {
        // тут всякие его поля
    };
    PhlegmAnalysisBody body;
    Phlegm( const unsigned char *data ): BCAR() {
        MemoryManager.alloc( size() );
        ::memcpy( &amp;body, data + sizeof( header ), sizeof( body ) );
    }
    . . .
};
</pre>
    <p align="justify">
      Где тут я обещал "виртуальный" конструктор? А вот он:
    </p>

<pre>
BCAR::BCAR( const unsigned char *dataStream ) {
    ::memcpy( &amp;header, dataStream, sizeof( header ) );
    if( CRC_OK( dataStream ) ) {
        // определяем тип конкретного результата
        // и строим соответствующий объект прямо на месте себя
        switch( AnalysisOf( dataStream ) ) {
            case PHLEGM:
                ::new( this ) Phlegm( dataStream );
                break;
            case BLOOD:
                ::new( this ) Blood( dataStream );
                break;
            case ...:
                . . .
        }
    . . .
}
</pre>
    <p align="justify">
      Теперь, чтобы не вынуждать вас носиться по всему письму в целях построения 
      целостной картины, объясняю происходящее по шагам.
    </p>
    <p align="justify">
      Менеджер памяти создан, инициализирован. Пул памяти существует (хотя бы от 
      обычного <code>malloc</code>, а хоть и с потолка -- ваше дело :). Есть некоторый поток байт 
      (пусть он зовётся stream), в котором то, с чем мы и боремся. Объект создаётся 
      следующим образом:
    </p>
<pre>
BCAR *analysis = new BCAR( stream );
</pre>
    <p align="justify">
      Обратите внимание -- мы создаём объект класса <code>BCAR</code>. В первую очередь 
      вызывается <code>BCAR::new</code>, который в действительности завуалированный 
      <code>MemoryManager.largest()</code>. Мы имеем адрес в свободной памяти, где и создаётся 
      объект <code>BCAR</code> и запускается его конструктор <code>BCAR::BCAR( const unsigned char * )</code>. 
      В конструкторе по информации из заголовка (полученного из потока stream) 
      выясняется точный тип анализа и через глобальный new (который не делает ничего 
      :) создаётся на месте объекта BCAR объект уточнённого типа. Hачинает 
      исполняться его конструктор, который в свою очередь вызывает конструктор 
      <code>BCAR::BCAR()</code>. Hадесь, стало понятно почему <code>BCAR::BCAR()</code> определяется с пустым 
      телом. Потом в конструкторе конкретного объекта вызывается <code>MemoryManager.alloc( int )</code>,
      благодаря чему менеджер памяти получает информацию о точном размере 
      объекта и соответствующим образом правит свои структуры. Уничтожение объектов 
      примитивно, ибо всей необходимой информацией <code>MemoryManager</code> располагает:
    </p>
<pre>
void BCAR::operator delete( void *p ) {
    MemoryManager.free( (BCAR *)p, ((BCAR *)p)->size() );
}
</pre>
    <p align="justify">
      Переносимость этой конструкции очень высока, хотя может понадобиться некоторая 
      правка для весьма экзотических машин. Факты же таковы, что она используется в 
      трёх очень крупных мировых центрах на четырёх аппаратных платформах и пяти 
      операционках.
    </p>
    <p align="justify">
      Hо это ещё не всё. Как особо дотошные могли заметить -- здесь присутствует 
      виртуальность конструктора, но в любом случае объект конкретного класса всё 
      равно имеет фиксированный размер. А вот объектов одного класса, но разного 
      размера нет. "А Hаумочкин, падла, обещал" :-)  До относительно недавнего 
      времени нас это вполне устраивало, пока не появились некоторые требования, в 
      результате которых нам пришлось сделать и это. Для этого у нас есть два (по 
      меньшей мере) способа. Один -- переносимый, но неэстетичный, а второй -- 
      непереносимый, но из common practice ;-)  Эта самая common practice состоит в 
      помещении последним членом класса конструкции вида <code>unsigned char storage[ 1 ]</code>
      в расчёте на то, что это будет действитетльно последним байтом во внутреннем 
      представлении объекта и туда можно записать не байт, а сколько надо. Стандарт 
      этого вовсе не гарантирует, но практика распространения нашего детища 
      показала, что для применяемых нами компиляторов оно именно так и есть. И оно 
      работает. Чуть-чуть поправим наши объекты:
    </p>
<pre>
class Blood: public BCAR {

friend BCAR;

private:
    int bodySize;
    int size() { return sizeof( Blood ) + bodySize; }
    int getSize( const char * );
    sturct BloodAnalysisBody {
        // тут его поля
    } *body;
    Blood( const unsigned char *data ): BCAR() {
        body = (BloodAnalysisBody *) bodyStorage;
        bodySize = getSize( data );
        ::memcpy( bodyStorage, data + sizeof( header ), bodySize );
        MemoryManager.alloc( size() );
    }
    unsigned char bodyStorage[ 1 ];
}
</pre>
    <p align="justify">
      Бороться с данными далее придётся через <code>body-></code>, но сейчас мы не об этом, да и 
      лечится оно :)
    </p>
    <p align="justify">
      Однако вспомним, что менеджер памяти у нас свой в доску :), и можем обойтись 
      действительно переносимой конструкцией. Тело анализа достаточно разместить 
      сразу за самим объектом, статический размер которого нам всегда известен. Ещё 
      чуть-чуть правим:
    </p>
<pre>
class Blood: public BCAR {

friend BCAR;

private:
    int bodySize;
    int size() { return sizeof( Blood ) + bodySize; }
    int getSize( const unsigned char * );
    struct BloodAnalysisBody {
       // тут его поля
    } *body;
    Blood( const unsigned char *data ): BCAR() {
       body = (BloodAnalysisBody *) ((unsigned char *)this 
               + sizeof( Blood ));
       bodySize = getSize( data );
       ::memcpy( body, data + sizeof( header ), bodySize );
       MemoryManager.alloc( size() );
    }
}
</pre>
    <p align="justify">
      Данные гарантированно ложатся сразу за объектом в памяти, которую нам дал 
      <code>MemoryManager</code> (а он, напомню, даёт нам всегда максимум из того, что имеет), а 
      затем alloc соответствующим образом всё подправит.
    </p>
    <p align="justify">
      Вот и вся любовь :)
    </p>
    <p align="justify">
      Alexander
    </p>
<h2>PS</h2>
    <p align="justify">
      Критиканам сразу сообщаю -- информацией о "потолках" и работе менеджера
      памяти вы не располагаете (а я не считаю нужным здесь её обсуждать в
      силу того, что она в данном случае -- лишние подробности. Основа --
      buddy system memory allocation algorithm имени Гарри Марковиц и Кеннета
      Hолтона), так что не надо о неработоспособности и подводных камнях. Где
      работает -- я уже поведал. Как работает? Прекрасно, иначе бы уже давно
      выкинули. Камни огорожены красными флажками...
    </p>





<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
