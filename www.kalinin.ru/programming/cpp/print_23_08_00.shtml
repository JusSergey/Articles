<html><head><title>ALK :: C&amp;C++ :: Свойства.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/23_08_00.shtml">http://www.kalinin.ru/programming/cpp/23_08_00.shtml</a><br>
<hr>
<br>

<h1>Свойства
</h1>
<p align="right">23.08.00</p>
 
    <p align="justify">
      Я уже говорил о <a href="26_07_00.shtml">C++ Builder</a> и хотя
      эта заметка не будет посвящена ему, тем не менее я о нем вспомню.
    </p>
    <p align="justify">
      Когда только появилась Delphi (первой версии) и ее мало кто видел,
      а еще меньше людей пробовали использовать, то в основном сведения
      об этом продукте фирмы Borland были похожи на сплетни. Я тогда
      был еще очень доверчив и мало чего знал, но от этого периода я отчетливо
      помню такое высказывание:  "Delphi расширяет 
      концепции объектно-ориентированного программирования за счет использования
      свойств". Перефразировав фразу из "Понедельник начинается в субботу"
      можно сказать, что я тогда был молод и верил во все, кроме существования бога ;)
    </p>
    <p align="justify">
      С тех пор я работал с C++ Builder и представляю себе, что такое его свойства.
      Кроме того, я теперь хоть как-то знаком с объектно-ориентированным анализом
      и проектированием, что бы понимать --- наличие в языке той или иной конструкции
      никак не влияет на используемые подходы. Мало того, префикс "ОО" обозначает не использование
      ключевых слов <code>class</code> или <code>property</code> в программах, а именно
      подход к решению задачи в целом (в смысле ее архитектурного решения). С этой
      точки зрения, будут использоваться свойства или методы <code>set</code> и <code>get</code>,
      совершенно без разницы --- главное разграничить доступ.
    </p>
    <p align="justify">
      Тем не менее, свойства позволяют использовать следующую конструкцию: описать функции для
      чтения и записи значения и связать их одним именем. Если обратиться к этому имени, то
      в разных контекстах будет использоваться соответственно либо функция для чтения значения,
      либо функция для его установки. 
    </p>
    <p align="justify">
      В свое время я участвовал в споре, смысл которого сводился к следующему: свойства
      очень удобны и наглядны, поэтому их надо ввести в стандарт языка. Я тогда утверждал,
      что нагромождение лишнего приведет к тому, что C++ станет вообще непонятным языком. Кроме
      того, я тогда сказал, что, скорее всего, свойства в таком виде реализуются и уже
      существующим набором средств. 
    </p>
    <p align="justify">
      Но перед тем, как я перейду к описанию реализации, я хотел бы высказаться по поводу
      удобства использования. Прямо скажем, программисты --- люди. Очень разные. Одним нравится
      одно, другое это ненавидят... в частности, возможность переопределения операций
      в C++ часто подвергается нападкам, при этом одним из основных аргументов
      (в принципе, не лишенный смысла) является то, что при виде такого выражения:
    </p>
<pre>
a = b;
</pre>
    <p class="table">
      нельзя сразу же сказать, что произойдет. Потому что на оператор присваивания можно
      "повесить" все что угодно. Самый распространенный пример "неправильного" (в смысле,
      изменение исходных целей) использования операций являются потоки ввода-вывода, в которых
      операторы побитового сдвига выполняют роль <code>printf</code>.  Примерно тоже нарекание
      можно отнести и к использованию свойств.
    </p>
    <p align="justify">
      Тем не менее, перейду к описанию примера. Итак, нужно оформить такой объект,
      при помощи которого можно было бы делать примерно следующее:
    </p>
<pre>
class Test
{
protected:
  int p_a;

  int&amp; setA(const int&amp; x);
  int getA();
public:
  /* ... */ a;
};

// ...

Test t;
t.a = 10;     // Вызов Test::setA()
int r = t.a;  // Вызов Test::getA()
</pre>
    <p align="justify">
      Естественный способ --- использовать шаблоны. Например, вот так:
    </p>
<pre>
template&lt;class A, class T,
  T&amp; (A::*setter)(const T&amp;),
  T (A::*getter)()
  &gt;
class property
{
  // ...
};
</pre>
    <p class="table">
      Параметр <code>A</code> --- класс, к которому принадлежат функции установки и чтения
      значения свойств (они передаются через аргументы шаблона <code>setter</code> и <code>getter</code>).
      Параметр <code>T</code> --- тип самого свойства (например, <code>int</code> для предыдущего примера).
    </p>
    <p align="justify">
      На запись, которая используется для описания указателей на функции, стоит обратить
      внимание --- я знаю, что многие программисты на C++ и не догадываются о том, что
      можно получить и использовать адрес функции-члена класса. Строго говоря, функция-член
      ничем не отличается от обычной, за исключением того, что ей требуется один
      неявный аргумент, который передается ей для определения того объекта класса,
      для которого она применятеся (это указатель <code>this</code>). Таким образом,
      получение адреса для нее происходит аналогично, а вот использование указателя
      требует указать, какой конкретно объект используется. Запись <code>A::*foo</code>
      говорит о том, что это указатель на член класса <code>A</code> и для его
      использования потребуется объект этого класса.
    </p>
    <p align="justify">
      Теперь непосредственно весь класс целиком:
    </p>
<pre>
template&lt;class A, class T,
  T&amp; (A::*setter)(const T&amp;),
  T (A::*getter)()
  &gt;
class property
{
protected:
  A * ptr;
public:
  property(A* p) : ptr(p) { }

  const T&amp; operator= (const T&amp; set) const
  {
    assert(setter != 0);
    return (ptr->*setter)(set);
  }
  operator T() const
  {
    assert(getter != 0);
    return (ptr->*getter)();
  }
};
</pre>
    <p align="justify">
      Я внес тела функций внутрь класса для краткости (на самом деле,
      общая рекомендация никогда не захламлять определения классов
      реализациями функций --- если нужен <code>inline</code>, то лучше
      его явно указать у тела подпрограммы, чем делать невозможным для
      чтения исходный текст. Мне приходилось видеть исходные тексты,
      в которых определения классов занимали по тысяче строк из-за
      того, что все методы были описаны внутри класса (как в Java). Это
      очень неудобно читать.
    </p>
    <p align="justify">
      Я думаю, что идея предельно ясна. Использование указателей на функцию-член
      заключается как раз в строках вида:
    </p>
<pre>
(ptr->*f)();
</pre>
    <p align="justify">
      Указатель внутри свойства --- это, конечно же, нехорошо. 
      Тем не менее, без него не обойтись --- указатель на объект
      нельзя будет передать в объявлении класса, только
      при создании объекта. Т.е., в параметры шаблона его никак не затолкать.
    </p>
    <p align="justify">
      Использовать класс <code>property</code> надо следующим образом:
    </p>
<pre>
class Test
{
  // ...
  property&lt;Test, int, &amp;Test::setA, &amp;Test::getA&gt; a;

  Test() : a(this) { }
};
</pre>
    <p align="justify">
      Компиляторы g++, msvc и bcc32 последних версий спокойно восприняли такое издевательство
      над собой. Тем не менее, более старые варианты этих же компиляторов
      могут ругаться на то, что используется незаконченный класс в параметрах шаблона,
      не понимать того, что берется адрес функций и т.д. Често говоря, мне
      кажется что стандарту это не противоречит. Но я не уверен в этом до конца --- тем
      более, что использовать это я не собираюсь.
    </p>
    <p align="justify">
      Тут я подошел к главному --- зачем все это нужно. А вообще не нужно ;) Я очень
      плохо себе представляю программиста, который решится на использование
      подобного шаблона --- это же просто нонсенс. Опять же, я не вижу
      никаких преимуществ по сравнению с обычным вызовом нужных функций и вижу
      один недостаток --- лишний указатель. Так что всю эту статью
      стоит рассматривать только как попытку продемонстрировать то, что можно получить при
      использовании шаблонов.
    </p>
    <p align="justify">
      На самом деле, теоретики "расширения концепций" очень часто забывают то, за
      что иногда действительно стоит уважать свойства. Это возможность сохранить
      через них объект и восстановить его (т.е., создать некоторое подобие
      persistent object). В принципе, добавить такую функциональность можно и
      в шаблон выше. Как? Это уже другой вопрос ;)
    </p>

<h2>Резюме</h2>
    <p align="justify">
      Свойства как расширение языка ничего принципиально нового в него не добавляют.
      В принципе, возможна их реализация средствами самого языка, но использовать
      такую реализацию бессмысленно. Догадываться же, что такой подход возможен --- полезно.
    </p>



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td>Бъерн Страуструп</td>
<td width="100%">
     Язык программирования C++, 3 издание. 
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
