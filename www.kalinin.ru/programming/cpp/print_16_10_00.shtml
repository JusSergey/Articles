<html><head><title>ALK :: C&amp;C++ :: Ploticus.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/16_10_00.shtml">http://www.kalinin.ru/programming/cpp/16_10_00.shtml</a><br>
<hr>
<br>

<h1>ploticus
</h1>
<p align="right">16.10.00</p>
 
    <p align="justify">
      Есть такая программа, предназначенная для создания графиков
      различных видов из командной строки, называется ploticus.
      Программа сама по себе достаточно удобная --- потому что 
      иногда очень полезно автоматизировать генерацию различных
      графических отчетов, а тут без командной строки и вызова
      программ из скриптов не обойтись. 
    </p>
    <p align="justify">
      Нет, таких программ великое множество, но ploticus отличается
      от них, как это мне сегодня объяснили, очень удобным
      преимуществом: он "глупый". То есть, его можно, например, заставить
      разместить надпись на рисунке с точностью до пикселя... иногда
      это нужно.
    </p>
    <p align="justify">
      Но разговор не об удобстве этой программы. Просто 
      "нам" (в смысле, конторе, где я сейчас работаю), потребовалось
      нечто подобное. Было решено использовать ploticus, но
      при этом немного доработанный напильником.
      Программист, который этим напильником орудовал, сегодня
      пребывал в особенно веселом настроении... почему --- ниже. 
    </p>
    <p align="justify">
      Сначала немного лирики. Ploticus, для того, что бы построить
      график, читает некоторый файл, в котором находится определение
      этого самого графика (скрипт, так сказать). Этот файл
      обладает очень простой грамматикой. Мало того,
      ploticus умеет организовывать программный канал (хотя, кто этого
      не умеет?) и читать данные оттуда, как результат выполнения другой
      программы. 
    </p>
    <p align="justify">
      Так вот о чтении этого файла я и хочу немного рассказать. Просто,
      программиста, который занимается работой с ploticus'ом, настолько
      поразила организация этого "счастья", что он сегодня
      к концу рабочего дня был уже совсем "не в себе" и занимался тем,
      что показывал избранные куски кода проходящим мимо людям.
    </p>
    <p align="justify">
      Итак, подпрограммы чтения данных в ploticus разбиты на некоторые логические
      блоки, исходя из структуры самого файла с данными. Ну это понятно и логично. 
      Не особенно понятно другое: каждая подпрограмма (парсер) на вход
      воспринимает название файла, в котором находится содержимое. В итоге, основная
      подпрограмма сначала разбивает файл на блоки, содержимое этих файлов
      копирует (!) во временные файлы (!!), которые подсовывает на вход
      другим подпрограммам. Это, конечно, уже достаточно оригинально, хотя
      задумка автора ясна --- он хотел сделать так, что бы в этих
      местах на вход подпрограммам чтения данных можно было
      бы подсунуть имя программы, которая эти данные бы сгенерировала. Тем
      не менее, можно было бы сделать значительно красивее, чем создавать
      кучу временных текстовых файлов.
    </p>
    <p align="justify">
      Эти "подпарсеры" реализованы... аналогичным образом. Т.е., автор
      не смущаясь разбивает подсунутые файлы еще на кусочки и записывает
      их в другие временные файлы, которые потом читает. 
    </p>
    <p align="justify">
      В принципе, все эти места как раз и требовали вмешательства напильника,
      потому что хотелось иметь программный интерфейс ко всему этому
      хозяйству и, желательно, что бы данные не покидали оперативной памяти.
    </p>
    <p align="justify">
      Все написанное выше уже смешно. Но кусочек кода, который я сейчас приведу,
      довел программиста до истерического смеха. Вот он (с купюрами):
    </p>
<pre>
/*
 * ...
 */
else if( stricmp( attr, "data" )==0 ) {
	FILE *tfp;
	sprintf( datafile, "%s_D", Tmpname );
	getmultiline( "data", lineval, fp, MAXBIGBUF, Bigbuf );
	tfp = fopen( datafile, "w" );
	if( tfp == NULL ) return( Eerr( 294, "Cannot open tmp data file", datafile ));
	fprintf( tfp, "%s", Bigbuf );
	fclose( tfp );
	}
/*
 * ...
 */
</pre>
    <p class="table">
      Это как раз и есть выделение секции с данными и запись ее во временный файл. Вообще, использование
      <code>fprintf</code> с шаблоном <code>"%s"</code> уже смотрится очень оригинально,
      но то, что идет 80 строками ниже еще более необычно:
    </p>
<pre>
/*
 * ...
 */
if( standardinput || strcmp( datafile, "-" ) ==0 ) 
{ /* a file of "-" means read from stdin */
	dfp = stdin;
	goto PT1;
	}
if( strlen( datafile ) > 0 ) sprintf( command, "cat %s", datafile );
if( strlen( command ) > 0 ) {
	dfp = popen( command, "r" );
	if( dfp == NULL ) {
		Skipout = 1;
		return( Eerr( 401, "Cannot open", command ) );
		}

	PT1:
/*
 * ...
 */
</pre>
    <p class="table">
      Прошу обратить внимание на строчку:
    </p>
<pre>
if( strlen( datafile ) > 0 ) sprintf( command, "cat %s", datafile );
</pre>
    <p class="table">
      и следующую за ней
    </p>
<pre>
	dfp = popen( command, "r" );
</pre>
    <p align="justify">
      Честно говоря, это впечатляет. Очень впечатляет... при этом, совершено не понятно что
      мешало использовать обычный <code>fopen()</code> для этого (раз уж так хочется),
      раз уж есть строки вида:
    </p>
<pre>
	dfp = stdin;
	goto PT1;
</pre>
    <p align="justify">
      В общем, дикость. Если кто-то не понял, то объясняю то, что происходит,
      на пальцах: читается секция "data" и ее содержимое записывается в файл,
      название которого содержится в <code>datafile</code>. Потом, проверяется
      название этого файла, если оно равно "-", то это значит, что данные
      ожидаются со стандартного файла ввода, <code>stdin</code>. Если же нет,
      то проверяется длина строки, на которую указывает <code>datafile</code>.
      Если она ненулевая, то считается, что команда, результаты работы которой будут
      считаться за входные данные, это "cat datafile". Если же ненулевая длина
      у другого параметра, <code>command</code>, то его значение принимается
      за выполняемую команду. После всех этих манипуляций, открывается
      программный канал (pipe) при помощи <code>popen()</code>, результатом
      которой является обычный указатель на структуру <code>FILE</code>
      (при его помощи можно использовать обычные средства ввода-вывода).
    </p>
    <p align="justify">
      Вам это не смешно?
    </p>

<h2>Резюме</h2>
    <p align="justify">
      Иногда лучше всего не заглядывать внутрь используемых программ...
      что бы не расстраиваться. 
    </p>	



<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td><a href="http://www.sgpr.net" target="_blank">http://www.sgpr.net</a></td>
<td width="100%">
     Официальная страница программы ploticus.
</td></tr>
<tr><td><a href="/comment/books/27_08_00.html">/comment/books/27_08_00.html</a></td>
<td width="100%">
     C и C++. Правила программирования.
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
