<html><head><title>ALK :: C&amp;C++ :: Правило "право-лево" разбора "сложных синтаксических конструкций".</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/cpp/17_07_00.shtml">http://www.kalinin.ru/programming/cpp/17_07_00.shtml</a><br>
<hr>
<br>

<h1>Правило "право-лево"
</h1>
<p align="right">17.07.00</p>
<table width="60%" cellspacing="0" cellpadding="0" align="center" border="0">
<tr><td>
<h2>Автор</h2>
<font size="-1">

    <p align="justify">
      Этот текст не мой. Авторство принадлежит Alexander V. Naumochkin (к сожалению,
      знаю только адрес в сети FIDO, 2:5020/59), на мой взгляд,
      один из самых грамотных C++ программистов, которых я когда-нибудь (лично или "виртуально")
      встречал. Тем не менее, считаю просто-таки своим долгом выложить
      этот текст здесь, потому что он отличается очень большой полезностью,
      а в FAQ конференции SU.C_CPP до сих пор не включен. Кроме того, я его больше
      нигде и не встречал, так что пусть здесь полежит. Надеюсь, Александр не обидится.
    </p>
</font>
</td></tr></table>


 
    <p class="question">
      А как вообще фоpмулиpуется основной пpинцип pазбоpа сложных
      синтаксических
      констpукций языка, навpоде "указатель на функцию, возвpащающую указатель
      на массив из тpёх указателей на функции, возвpащающие значение int"?
    </p>
    <p align="justify">
      Давно и чётко формализовано в виде правила "право-лево". Всё предельно просто.
      Имеем:
    <ul>
      <li> <code>()</code> - функция, возвращающая...</li>
      <li> <code>[]</code> - массив из...</li>
      <li> <code>*</code> - указатель на...</li>
    </ul>
  </p>
    <p align="justify">
      Процесс разбора итеративный:
    <ol type="1">
      <li>Первым делом находим имя, от которого и будем плясать. Пляски начинаются
	со слов "Имя есть..."
      </li>
      <li> Следующий шаг - шаг вправо. Что там у нас справа? Если <code>()</code>, то говорим,
	что "Имя есть функция, возвращающая...". (если промеж скобок что-то есть,
	то "Имя есть функция, принимающая то, что между скобок, и возвращающая...")
	Если там <code>[]</code>, то "Имя есть массив из..."  И таким вот образом мы идём
	вправо до тех пор, пока не дойдём до конца объявления или правой <code>)</code> скобки.
	Тут тормозим...
      </li>
      <li> ...и начинаем танцевать влево. Что у нас слева? Если это что-то не из
	приведённой выше таблицы (то есть не <code>()</code>, <code>[]</code>, <code>*</code>), то просто добавляем к
	уже имеющейся расшифровке. Если же там что-то из этих трёх символов, то
	добавляем то, что написано в таблице. И так танцуем до тех пор, пока не
	дотанцуем до конца (точнее - начала объявления) или левой <code>(</code> скобки.
	Если дошли до начала, то всё готово. А если дошли до <code>(</code>, то по уже
	означенной итеративности переходим к шагу 2 - пляски вправо продолжаем.
      </li>
    </ol>
  </p>	
    <p align="justify">
      Пример:
    <pre>
        int (*(*(*fptr)())[3])();
                  ^^^^
    </pre>

    <ol type="1">
      <li> Hаходим имя и записываем "fptr есть..."</li>
      <li> Шаг вправо, но там <code>)</code>, потому идём влево
	<pre>
        int (*(*(*fun)())[3])();
                 ^
	</pre>
	и получаем "fptr есть указатель на..."
      </li>
      <li> Продолжаем ехать влево, но тут <code>(</code>. Идём вправо
	<pre>
        int (*(*(*fun)())[3])();
                      ^^
	</pre>
	получаем "fptr есть указатель на функцию, возвращающую..."  Снова <code>)</code>,
	опять влево.
      </li>
      <li> Получаем
	<pre>
        int (*(*(*fun)())[3])();
               ^
	</pre>
	"fptr есть указатель на функцию, возвращающую указатель на..."  Слева
	опять <code>(</code>, идём вправо.
      </li>
      <li> Получаем
	<pre>
        int (*(*(*fun)())[3])();
                         ^^^
	</pre>
	"fptr есть указатель на функцию, возвращающую указатель на массив из
	трёх..."  И снова справа <code>)</code>, отправляемся влево
      </li>
      <li> Получаем
	<pre>
        int (*(*(*fun)())[3])();
             ^
	</pre>
	"fptr есть указатель на функцию, возвращающую указатель на массив из трёх
	указателей на..."  Снова разворот вправо по причине <code>(</code>
      </li>
      <li> Получаем
	<pre>
        int (*(*(*fun)())[3])();
                             ^^
	</pre>
	"fptr есть указатель на функцию, возвращающую указатель на массив из трёх
	указателей на функции, возвращающие..."  Тут конец описания, поехали
	влево и получили окончательную расшифровку этой каракули
      </li>
      <li>
	<pre>
        int (*(*(*fun)())[3])();
        ^^^
	</pre>
	"fptr есть указатель на функцию, возвращающую указатель на массив из трёх
	указателей на функции, возвращающие <code>int</code>"
      </li>
    </ol>
    Именно то, чего ты и хотел. Просто?
  </p>





<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
