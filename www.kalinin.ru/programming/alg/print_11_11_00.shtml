<html><head><title>ALK :: Алгоритмы :: Полный перебор.</title>
</head>
<body bgcolor="white" text="black">
<a href="http://counter.rambler.ru/top100/"><img align="left" src="http://counter.rambler.ru/top100.cnt?160852" alt="Rambler's Top100 Service" width=1 height=1 border=0></a>
Этот текст распечатан с домашней странички Андрея Калинина 
(<a href="http://www.kalinin.ru">www.kalinin.ru</a>).<br>
Оригинал статьи находится по этому адресу: <a href="http://www.kalinin.ru/programming/alg/11_11_00.shtml">http://www.kalinin.ru/programming/alg/11_11_00.shtml</a><br>
<hr>
<br>

<h1>Полный перебор
</h1>
<p align="right">11.11.00</p>
 
    <p align="justify">
      Зачастую, когда говорят о качестве решения некоторой
      задачи, для того что бы определить наихудший вариант,
      приводят пример "полного перебора". Сколько раз
      я уже слышал от разных людей: &quot;если задача решена
      не простым перебором, то это уже хорошо&quot;...
    </p>
    <p align="justify">
      На самом деле, если человек никогда сам полный
      перебор ни разу не организовывал, то, скорее
      всего, эта задача вызовет у него некоторые сложности.
      Связано это просто с отсутствием понимания
      того, как перебор надо устраивать, что для этого
      надо хранить в памяти и как этим пользоваться.
      И вообще, есть ситуации, когда перебор --- единственный
      способ найти решение; самым сложным тогда становится
      ограничить область перебора. 
    </p>
    <p align="justify">
      Вообще говоря, перебор имеет смысл в том случае,
      когда каким-то образом ограничено множество
      возможных решений задачи и, кроме того, это
      множество является счетным. Тогда, в принципе,
      можно взять каждое потенциальное решение из
      этого множества и просто проверить его,
      подставив в условие задачи. 
    </p>
    <p align="justify">
      Ключевыми словами в предыдущем абзаце
      является счетность и конечность. В этом
      случае, все элементы множества потенциальных
      решений можно будет просто пронумеровать от 0 до
      некоторого N (вполне определенное число для
      конкретной задачи) и в цикле от нуля до N
      произвести подстановку вариантов решения в условие.
      На самом деле, лучше выделить переход от
      известного элемента этого множества к следующему,
      использование которого позволит более ясным способом 
      (без приписывания номеров элементам множества)
      произвести перебор.
    </p>
    <p align="justify">
      Что бы не быть голословным, приведу пример
      обычной задачи на перебор. Задача предлагалась
      на олимпиаде ВМК в 1998 году (задача C, 
      &quot;парламент&quot;):
    </p>
<table align="center" border="0" cellspacing="0" cellpadding="5" width="60%">
<tr><<td bgcolor="#cccccc" width="100%" nowrap>Цитата</td></tr>
<tr><td></td></tr>
<tr>
<td colspan="2" width="100%">
    <p align="justify">
      Совсем недавно в Одном Островном Государстве разразился 
      правительственный кризис, в результате которого все правительство 
      во главе с премьер-министром было отправлено в отставку. По Конституции 
      государства, новый премьер-министр назначается президентом, но должен 
      пройти процедуру утверждения своей кандидатуры в парламенте. Зная 
      оппозиционные настроения парламента по отношению к новой 
      кандидатуре премьер-министра, президент решил обратиться 
      за помощью к некоему финансовому магнату, имеющему близкие 
      связи с кандидатом в премьеры и заинтересованному в утверждении.
    </p>
    <p align="justify">
      Финансовый магнат выделяет некоторую сумму X тугриков (6 тугриков примерно 
      равны 1 доллару США), которая должна быть истрачена на убеждение депутатов 
      в необходимости утверждения кандидата. Парламент 
      государства состоит из N (0 &lt; N &lt; 1000) депутатов, которые всегда 
      ходят на все заседания и голосуют всегда либо за, либо против (воздержавшихся 
      и не голосовавших не бывает). О каждом депутате i парламента известно априорное 
      отношение этого депутата к кандидатуре премьер-министра, выражаемое в 
      вероятности p<sup>0</sup><sub>i</sub> (0 &lt;= p<sup>0</sup><sub>i</sub> &lt;= 1), с которой 
      данный депутат проголосует за 
      кандидатуру. Однако если на убеждение депутата 
      потратить K<sub>i</sub> тугриков, депутат обычно обещает 
      поддержать кандидата, но, поскольку голосование тайное, в 
      действительности депутат голосует за с вероятностью p<sup>1</sup><sub>i</sub> 
      (0 &lt;= p<sup>1</sup><sub>i</sub> &lt;= 1). По предыдущему опыту общения президента с 
      парламентом известно, что если президенту удается заручиться предварительной 
      поддержкой 70% голосов депутатов, нужное решение всегда проходит.       
    </p>
    <p align="justify">
      С другой стороны, президент желал бы сэкономить как можно больше 
      денег, ибо его финансовое положение несколько пошатнулось в 
      результате кризиса на азиатских рынках. Поэтому он готов 
      заплатить 10% от сэкономленной суммы за наилучший вариант 
      убеждения депутатов и за сохранение конфеденциальности. Экспертная 
      группа при президенте готова произвести необходимые расчеты, но 
      при условии, что она в любом случае получит как минимум M 
      тугриков (и как максимум -- 10% от сэкономленной суммы). Если 
      выделенная магнатом сумма будет меньше M, то группа отказывается 
      даже производить расчет. Если сумма будет больше M, но окажется 
      недостаточной для обеспечения прохождения кандидатуры (с учетом оплаты 
      работы группы), группа расчитает, на какой максимальный процент голосов в 
      поддержку может расчитывать президент. Весь остаток суммы X, не 
      потраченный на депутатов и группу экспертов, остается в распряжении президента. 
    </p>
</td></tr>
</table>
    <p align="justify">
      Полный текст задачи (основную его часть я привел выше) можно
      посмотреть <a href="http://unicorn.cmc.msu.ru/problems/1998-1/c/">здесь</a>.
    </p>
    <p align="justify">
      Таким образом, надо рассчитать, кому из депутатов надо
      дать некоторое количество &quot;тугриков&quot;; кроме того,
      решение должно быть оптимальным в некотором смысле (описанном в третьем
      абзаце условия задачи). Вообще, оптимальность решения зачастую
      указывает именно на то, что потребуется перебор (хотя есть
      теория оптимизации, которая занимается поиском методов решения
      подобных задач без перебора, существует множество задач, для которых
      пока что нет иных способов точного (!) решения).
    </p>
    <p align="justify">
      Решением задачи, по сути, будет являться набор индексов депутатов,
      которым надо будет заплатить. Для каждого из депутатов есть только
      два варианта: либо ему платят, либо нет; соответственно множество
      возможных решений есть набор упорядоченных N-ок, на i-ой позиции
      в которых находится флаг &quot;платить/не платить&quot; для
      i-го депутата. Нетрудно видеть, что эти &quot;упорядоченные N-ки&quot;
      являются N-разрядными числами, представленными в двоичной системе счисления. Соответственно,
      множество возможных решений будет содержать в себе все возможные
      варианты таких чисел, т.е. элементом этого множества будет являться
      число от 000..0<sub>2</sub> до 111..1<sub>2</sub>.  Соответственно,
      очень просто сделать перебор элементов множества в естественном порядке
      &quot;по возрастанию&quot;, прибавляя 1 к текущему числу, начиная с 0 и кончая
      2<sup>N</sup>-1. 
    </p>
    <p align="justify">
      Выглядит это примерно следующим образом:
    </p>
<pre>
struct deputat
{
    float p0;
    float p1;
    int K;
};

deputat* d;
bool*    state;
int N, X, M;
</pre>
<table align="right" border="0" cellspacing="0" cellpadding="5" width="150">
<tr><td></td></tr>
<tr><td>&nbsp;</td>
<td bgcolor="#cccccc" width="100%" nowrap>Лирическое отступление:</font></td>
</tr>
<tr><td colspan="2"></td></tr>
<tr>
<td>&nbsp;</td>
<td>
    <p align="justify">
      Массив элементов типа <code>bool</code> на самом деле
      не является хорошим решением для
      хранения &quot;флагов&quot; потому что 
      размер переменной <code>bool</code> как минимум
      1 байт (т.е., 8 бит), что несколько
      расточительно. Вообще говоря, никто не мешает
      уменьшить размер массива в 8 раз и для проверки или установки
      флагов в массиве использовать операции индексации внутри
      массива вместе с битовыми операциями над целыми числами. 
    </p>
    <p align="justify">
      К слову сказать, в STL уже существуют необходимые
      шаблонные классы для этого. Например, <code>std::vector&lt;bool&gt;</code>
      является битовым массивом, а не массивом
      элементов  типа <code>bool</code>, так как реализован
      в виде специализации основного шаблона <code>std::vector&lt;T&gt;</code>.
      Кроме того, существует шаблон <code>std::bitset</code>, реализующий
      конечное счетное множество элементов на битовом массиве.
    </p>
</td></tr></table>
    <p align="justify">
      В переменных <code>N</code>, <code>X</code>, <code>M</code> и массиве
      <code>d</code> размера <code>N</code> содержится информация, которая задается
      на входе.
      В массиве <code>state</code> (в смысле, что этот указатель после чтения данных
      будет указывать на область памяти, в которой содержится N элементов <code>bool</code>)
      содержится текущий элемент из множества возможных решений. Если <code>state[i]</code> 
      содержит в себе <code>true</code>, то на i-го депутата тратятся деньги и наоборот.
    </p>
<pre>
double Q;
int Td, Te, Tp;
</pre>
    <p align="justify">
      Эти переменные имеют смысл в рассматриваемой задаче и в них
      будут находится текущие &quot;лучшие&quot; значения требуемых
      параметров.
    </p>
    <p align="justify">
      Теперь опишем подпрограмму, которая будет по текущему
      элементу перебираемого множества строить следующий элемент.
    </p>
<pre>
bool next()
{
  int i = N-1;

  for(; i >= 0; i--)
    if(state[i])
      state[i] = false;
    else
      {
        state[i] = true;
        break;
      }

  return(i < 0 &amp;&amp; !state[0]);
}
</pre>
    <p align="justify">
      Подпрограмма очень простая и всего навсего реализует 
      прибавление 1 к числу, записанному в двоичной системе счисления.
      Возвращаемое значение --- <code>true</code>, если 
      произошло переполнение при сложении. Эта ситуация
      возникает тогда, когда добавляют единицу к N-разрядному
      числу 111..1<sub>2</sub> (не хватает разрядов
      для записи результата), т.е., фактически, 
      означает конец перебора. В начале программы, понятно,
      массив <code>state</code> инициализируется значениями <code>false</code>.
    </p>
    <p align="justify">
      Кроме того, понадобится подпрограмма &quot;проверки качества&quot;
      текущего решения (по отношению
      к уже отобранному).
    </p>
<pre>
void check()
{
  double Q = 0.;
  int Td = 0, Te, Tp;
    
   /*
    * Вычисляем значения локальных
    * переменных Q, Td, Te и Tp исходя
    * из state.
    */

   // ...

   /*
    * Если значения локальных переменных
    * Q, Td, Te и Tp "лучше", чем значения
    * глобальных переменных ::Q, ::Td, ::Te
    * и ::Tp, то заменяем значения глобальных
    * переменных локальными.
    */

    if( ... )
      {
        ::Te = Te;
        ::Td = Td;
        ::Tp = Tp;
        ::Q = Q;
      }
}
</pre>
    <p align="justify">
      Сами вычисления нас сейчас не особенно интересуют, потому что это ---
      ненужные тонкости. Дополняет общую картину еще один цикл,
      который обе эти функции связывает воедино:
    </p>
<pre>
for(;;)
  {
     check();
     if(next()) break;
  }
</pre>
    <p align="justify">
      Собственно, это все: после завершения работы этого цикла в глобальных
      переменных <code>Q</code> и т.д. будут находится искомые значения. А 
      теперь о грустном. Внутренность внешнего цикла
      исполнится ровно 2<sup>N</sup> раз, т.е. именно столько раз
      будут вызваны внутренние функции. На каждый вызов тратится машинное
      время... в общем, то что я эти две части внутреннего цикла оформил
      в виде подпрограмм, еще не значит, что надо так же делать в реальной
      жизни: очень часто замена подпрограммы на непосредственное включение
      кода в точки вызова (через <code>inline</code> или <code>#define</code>)
      приводило к ускорению работы &quot;в целом&quot; в несколько раз. 
    </p>
    <p align="justify">
      Теперь уж о совсем грустном... если для некоторого N работа
      программы, построенной при помощи полного перебора
      еще хоть как-то удовлетворяет, то для N+1, скорее всего, скорость
      работы перестанет быть удовлетворительной. Это логично: потому
      что при включении еще одного депутата в парламент, количество
      вычислений удвоится! Что терпимо для относительно маленьких
      N, но совершенно не подходит для больших N. 
    </p>
    <p align="justify">
      Проблема в данном случае состоит еще и в том, что 
      ее нельзя решить простым наращиванием ресурсов
      компьютера (купив более быстрый процессор, или
      увеличив количество оперативной памяти), потому что
      скорости компьютера увеличиваются линейно, а количество
      вычислений при помощи предложенного алгоритма --- по экспоненте.
    </p>
    <p align="justify">
      О том, как практически попытаться улучшить полный перебор, я
      расскажу позже, а пока что намечу основной путь решения.
      Понятно, что если &quot;красивого&quot; решения
      у задачи не существует, то ничем принципиальным перебор
      ускорить будет нельзя. Тем не менее, если вы внимательно
      посмотрите на предложенную схему его реализации, то 
      заметите одну достаточно забавную вещь: если для некоторого
      подмножества депутатов улучшить значения глобальных
      переменных, отвечающих за &quot;качество&quot; решения
      нельзя, т.е. если эти депутаты будут находится в любом
      другом множестве &quot;оплаченных&quot; депутатов, то 
      решение задачи заведомо будет хуже уже найденного, следовательно
      все решения задачи, которые включают этот набор депутатов, 
      можно даже не проверять. 
    </p>
    <p align="justify">
      В реализованной схеме решения задачи достаточно сложно 
      учитывать подобные моменты, но тем не менее, возможно
      применить подобные размышления... например, просто убрав
      из исходного множества всех депутатов, у которых
      значение K<sub>i</sub> больше всего имеющегося
      в наличии у президента &quot;тугриков&quot;. Это очень
      просто сделать, но каждый такой депутат уменьшит количество
      вычислений по отношению к исходной задаче вдвое!
    </p>
    <p align="justify">
      Тем самым, мы подошли к методу перебора, который называется &quot;методом
      ветвей и границ&quot;. Он не может дать качественного изменения
      поведения перебора для всех возможных начальных данных,
      но в целом очень сильно ускоряет процесс. 
    </p>
    <p align="justify">
      Еще один недостаток описанного подхода заключается
      в том, что значения переменных постоянно пересчитываются
      заново при переходе от одного числа к другому. Вообще
      говоря, если сменить метод перехода от элемента к элементу,
      можно в некоторых случаях использовать значения,
      посчитанные на предыдущем шаге (просто прибавляя или вычитая
      из них некоторое значение). Кроме того, можно хранить
      вообще все расчеты, используя их при последующих
      итерациях (это будет полезно сделать, если вы сможете
      организовать удобный и быстрый способ доступа к ним впоследствии) 
      --- такое улучшение описанного решения
      приведет к решению задачи другим методом, называемом &quot;динамическим
      программированием&quot;. Такой алгоритм ускорит работу программы за счет
      больших требований к оперативной памяти.
    </p>
    <p align="justify">
      Более подробно эти методы я рассмотрю позже, а если кто-то
      заинтересовался, то ссылки на книги можно найти внизу этой
      заметки.
    </p>

<h2>Резюме</h2>
    <p align="justify">
      То, что полный перебор неэффективен, еще не значит, что
      его просто использовать в своих программах. Зачастую
      мешается много деталей, которые программисты упускают
      из вида при начале программирования. Кроме того, 
      надо знать основные способы модификации полного перебора,
      при помощи которых можно несколько ускорить работу
      программы.
    </p>
<h2>PS</h2>
    <p align="justify">
      Задача решена методом полного перебора для того,
      что бы продемонстрировать этот метод. 
      В данном случае полный перебор не является самым эффективным
      решением задачи.
    </p>




<h2>Ссылки по теме</h2>


<table width="100%" border="0" cellspacing="0" cellpadding="5">
<tr><td><a href="/comment/books/11_07_00.shtml">/comment/books/11_07_00.shtml</a></td>
<td width="100%">
 Программирование: теоремы и задачи.
</td></tr>
<tr><td>Н.&nbsp;Вирт</td>
<td width="100%">
 Алгоритмы + Структуры данных = Программы.
</td></tr>
</table>


<hr>
&copy;2000-2001 by Andrey L. Kalinin, 
<a href="http://counter.rambler.ru/top100/" alt="Rambler's Top100" target="_blank"><img align=right src="http://images.rambler.ru/top100/banner-88x31-rambler-black2.gif" border=0 width=88 height=31></a>
<br>
andrey@kalinin.ru
</body>
</html>
