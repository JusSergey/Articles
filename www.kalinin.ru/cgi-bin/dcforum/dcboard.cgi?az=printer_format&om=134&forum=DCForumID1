<html><head></head><body color="#FFFFFF">

   <font face="arial,sans-serif" size="2" color="#000099">
   <b>
   URL: /cgi-bin/dcforum/dcboard.cgi<br>
   Forum: DCForumID1<br>
   Thread Number: 134<br>
   [ <a href="http://www.kalinin.ru/dcforum//DCForumID1/134.html">Go back to previous page</a> ]
   </b><hr>
   
<b><font size=2>Original Message<hr>"Большое зло"</font></b><br>
Posted by Ilias  on 19-Mar-04 at 02:05&nbsp;PM<br>
<blockquote>Андрей, а почему ты считаешь переопределение операторов большим злом? Ну допустим, чтобы кому-то понадобилось переопределить operator=, чтобы он форматировал винт. Но ведь с тем же успехом можно переопределить и printf, чтобы она форматировала винчестер!<P>По-моему, либо надо вообще запретить переопределение, либо его разрешить. Я не понимаю, в чем разница между операторами и функциями, особенно учитывая что можно (при некоторых условиях) написать что-то в духе<P>int a = operator (1, 5);<P>Вообще, переопределением операторов занимаются давно и успешно:   означает сложение чисел, матриц, функций, операторов. А ||.|| - норма, которую определяют чуть ли не полусотней способов. Все к этому привыкли и не имеют вопросов. И потом,<P>x = x_prev - f(x_prev) / df(x_prev);<P>все-таки немного понятнее, чем<P>assign(x, subtract(x_prev, division(f(x_prev), df(x_prev))); <P>просто в силу привычки. С чего, собственно, Страуструп и начинает главу про переопределение.</blockquote><hr><b><font size=2>Table of contents</font></b><hr>
<ul>
<li><b>RE: Большое зло</b>,<b>Andrey L. Kalinin</b>, 02:35&nbsp;PM, 19-Mar-04
</ul>
<hr><b><font size=2>Messages in this discussion</font></b><hr>
<b>"RE: Большое зло"</b><br>
Posted by Andrey L. Kalinin  on 19-Mar-04 at 02:35&nbsp;PM<br>
<blockquote>
&gt;Андрей, а почему ты считаешь переопределение <BR>&gt;операторов большим злом?<P>Исключительно из собственных наблюдений за жизнью. <P>&gt; Ну допустим, <BR>&gt;чтобы кому-то понадобилось переопределить operator=, <BR>&gt;чтобы он форматировал винт. Но <BR>&gt;ведь с тем же успехом <BR>&gt;можно переопределить и printf, чтобы <BR>&gt;она форматировала винчестер! <P>Нет, дело не в этом. <P>printf всегда останется printf'ом, варианты когда некий человек подменяет системную библиотеку, отвергаем сразу: он либо знает что делает, либо полный идиот. <P>А оператор "присвоить", определенный для некоторого класса, очень опасен именно тем, что его легко использовать, не подумав что за ним стоит. <P>Вот например, есть некоторый класс, который реализует какое-то хранилище. И где-то посередине программы находится конструкция A=B. Что она сделает? Что это значит --- копирование данных, или использование разделяемой памяти? <P>&gt;По-моему, либо надо вообще запретить переопределение, <BR>&gt;либо его разрешить. Я не <BR>&gt;понимаю, в чем разница между <BR>&gt;операторами и функциями, особенно учитывая <BR>&gt;что можно (при некоторых условиях) <BR>&gt;написать что-то в духе <BR>&gt;<BR>&gt;int a = operator (1, 5); <BR>&gt;<BR>&gt;<BR>&gt;Вообще, переопределением операторов занимаются давно и <BR>&gt;успешно:   означает сложение <BR>&gt;чисел, матриц, функций, операторов. А <BR>&gt;||.|| - норма, которую определяют <BR>&gt;чуть ли не полусотней способов. <BR>&gt;Все к этому привыкли и <BR>&gt;не имеют вопросов. И потом, <BR>&gt;<BR>&gt;<BR>&gt;x = x_prev - f(x_prev) / <BR>&gt;df(x_prev); <BR>&gt;<BR>&gt;все-таки немного понятнее, чем <BR>&gt;<BR>&gt;assign(x, subtract(x_prev, division(f(x_prev), df(x_prev))); <BR>&gt;<BR>&gt;просто в силу привычки. С чего, <BR>&gt;собственно, Страуструп и начинает главу <BR>&gt;про переопределение. <P><BR>Да ничего тут не понятнее.<P>В программировании всегда существует обычный trade-off между удобством программирования и точностью понимания того, как работает программа. <P>Вот попросту свежий пример: некая программа работала достаточно медленно. Изучение результатов профайлера для нее в разных ситуациях показало, что достаточно большое время она проводит в... операторе присваивания std::string! При этом реальное копирование нигде не требовалось. Замена в глубине программы в параметрах функций std::string на const char * привело к увеличению производительности процентов на 30. Что в данном случае было очень важно. <P>Вопрос --- кто виноват и что делать? Виновато удобство использования оператора присваивания и конструктора копирования, когда его очень просто поставить не понимая физических процессов, происходящих внутри. Делать тоже понятно что --- избавляться от удобства и думать над каждой строчкой, если оно требуется.<P>Просто существуют разные программы, с разными требованиями к их качеству и т.п. Все новшества в C  , фактически, предназначены для того, чтобы сделать универсальную удобную среду программирования. Если нужно сделать программу, к которой не выдвигается серьезных требований по качеству (гарантированное время отклика, ограничения на объем оперативной памяти, еще что-нибудь про поведение программы при изменении размерности входных данных), то использование STL и всего новомодного вполне оправдано: тем самым мы превращаем язык C в подобие Perl'а и наслаждаемся результатами.<P>Но как только требования ужесточается, все это прекращает работать. Совсем. Все приходиться писать сызнова. <P>Вообще, в таких случаях удобство программирования отходит на второй план. Да и вообще, сам аргумент "удобнее" (или "привычнее") здесь не работает: привыкнуть можно к чему угодно и тогда именно этот подход станет удобным. В свое время программисты достаточно успешно программировали в машинных кодах (да и сейчас можно встретить таких --- с узкой специализацией). <P>Это же все уровни программирования: чем выше, тем проще и быстрее программировать, но качество становится хуже за счет использования неконтроллируемых компонент. Если же опускаемся ниже, то время (и цена) разработки стремительно растет, зато мы можем предоставлять гарантии относительно качеств продукта.<BR>
</blockquote>
<hr>
</font></body></html>
