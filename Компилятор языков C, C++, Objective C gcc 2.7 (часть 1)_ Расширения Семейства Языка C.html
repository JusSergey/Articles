<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- saved from url=(0047)https://www.opennet.ru/docs/RUS/gcc/gcc1-4.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=KOI8-R">

 <meta name="GENERATOR" content="SGML-Tools 1.0.9">
 <title>Компилятор языков C, C++, Objective C gcc 2.7 (часть 1): Расширения Семейства Языка C</title>
 <link href="https://www.opennet.ru/docs/RUS/gcc/gcc1-3.html" rel="previous">
 <link href="https://www.opennet.ru/docs/RUS/gcc/gcc1.html#toc4" rel="contents">
<link rel="preload" href="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/integrator.js" as="script"><script src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/ca-pub-2075278885744463.js"></script><script type="text/javascript" src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/integrator.js"></script><link rel="preload" href="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/integrator(1).js" as="script"><script type="text/javascript" src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/integrator(1).js"></script></head>
<body bgcolor="#DDE1C2">
<link rel="stylesheet" href="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="https://www.opennet.ru/search.shtml">
<aside>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tbody><tr>
<td valign="BOTTOM" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left">
<a href="https://www.opennet.ru/"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/opennet2.gif" height="60" width="249" alt="The OpenNET Project" border="0"></a><br>
</td>

<td bgcolor="#B0B190" width="1"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="1" width="1" alt=""></td>

<td valign="TOP" align="RIGHT" width="728" height="90" bgcolor="#D9DAC6">
<table border="0" cellpadding="0" width="728">
<tbody><tr>
<td height="90" bgcolor="#D9DAC6">
<p></p>

<script async="" src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/analytics.js"></script><script async="" src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/adsbygoogle.js"></script>
<!-- bigban -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-2075278885744463" data-ad-slot="4566802230" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe width="728" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:728px;height:90px;" src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/saved_resource.html"></iframe></ins></ins></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</td>
</tr>
</tbody></table>
</td>

<td bgcolor="#B0B190" width="1"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="1" width="1" alt=""></td>
<td width="40" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left">&nbsp;</td>
<td bgcolor="#B0B190" width="1"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="1" width="1" alt=""></td>

<td valign="TOP" align="RIGHT" width="0" bgcolor="#E9EAD6" rowspan="3">
</td>

</tr>

<tr bgcolor="#B0B190"><td colspan="6"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="1" width="1" alt=""></td></tr>


<tr bgcolor="#E9EAD6">
<td align="CENTER" colspan="5">
<table width="100%">
<tbody><tr>
<td rowspan="2" width="300" nowrap="" class="h">
<input type="hidden" name="exclude" value="index|/man.shtml"><a href="https://www.opennet.ru/search.shtml" class="h"><u>Поиск</u></a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>):&nbsp;<input type="text" size="20" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;">
</td><td width="20%">
&nbsp;   <a href="https://www.opennet.ru/opennews/" class="h"><b><u>НОВОСТИ</u></b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="20%">
  <a href="https://www.opennet.ru/mp/" class="h"><b><u>КОНТЕНТ</u></b></a>
</td><td width="18%">
  <a href="http://wiki.opennet.ru/" class="h"><b><u>WIKI</u></b></a>
</td><td width="18%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b><u>MAN'ы</u></b></a>
</td><td width="18%">
   <a href="https://www.opennet.ru/forum/" class="h"><b><u>ФОРУМ</u></b></a>
</td><td width="6%" align="right">
   <a href="https://twitter.com/opennetru"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/twitter.png" height="16" width="16" alt="twitter" title="Twitter" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/vkontakte.gif" height="16" width="16" title="ВКонтакте" border="0"></a>&nbsp;<a href="https://t.me/opennet_ru"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/telegram2.png" height="16" width="16" title="Telegram" border="0"></a>
</td></tr>
</tbody></table>
</td>
<td bgcolor="#B0B190" width="1"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="1" width="1" alt=""></td>
</tr>
<tr bgcolor="#B0B190"><td colspan="7"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="2" width="1" alt=""></td></tr>
</tbody></table>
</aside>
<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="https://www.opennet.ru/"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="https://www.opennet.ru/opennews/">новости</a>/<a href="https://www.opennet.ru/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">++</a> | <a href="https://www.opennet.ru/forum/">форум</a> | <a href="http://wiki.opennet.ru/">wiki</a> | <a href="https://www.opennet.ru/keywords/">теги</a>
]</small>
<a href="https://t.me/opennet_ru"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/telegram2.png" height="16" width="16" title="Telegram" border="0"></a>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv"><a href="http://www.ip-as.ru/" target="_blank"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/ipas3.gif" border="0" width="279" height="40"></a></div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->


<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin-bottom: 5px;margin-top: 5px;">
<tbody><tr><td>
<table border="0" cellspacing="0" cellpadding="4" bgcolor="#E9EAD6" width="100%">
<tbody><tr bgcolor="#C7CBB1"><td><font color="#000090">
<b><a href="https://www.opennet.ru/docs/">Каталог документации</a> / 
<a href="https://www.opennet.ru/docs/124.shtml">Раздел "Программирование, языки"</a> /
<a href="https://www.opennet.ru/docs/RUS/gcc/">Оглавление документа</a>
</b>
</font></td></tr>
</tbody></table>
</td></tr>
<tr bgcolor="#B0B190"><td><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/p.gif" height="3" width="1" alt=""></td></tr>
</tbody></table>

Вперед
<a href="https://www.opennet.ru/docs/RUS/gcc/gcc1-3.html">Назад</a>
<a href="https://www.opennet.ru/docs/RUS/gcc/gcc1.html#toc4">Содержание</a>
<hr>
<h2><a name="s4">4. Расширения Семейства Языка C</a></h2>

<p>
</p><p>GNU C обеспечивает некоторые языковые свойства, отсутствующие в
стандарте ANSI C. (Опция `-pedantic` указывает GNU CC печатать
предупреждающее сообщение, если какое-нибудь из этих свойств
используется.) Чтобы проверить доступность этих свойств в условной
компиляции, проверьте предопределенный макрос __GNUC__, который всегда
определен под GNU CC.
</p><p>Эти расширения доступны в C и в Objective C. Большая часть из них
также доступна в C++.
</p><p>
</p><h2><a name="ss4.1">4.1 Операторы и Объявления в Выражениях</a>
</h2>

<p>
</p><p>Составной оператор, заключенный в скобки, может появляться в
качестве выражения в GNU C. Это позволяет вам использовать циклы,
операторы выбора и локальные переменные внутри выражения.
</p><p>Напомним, что составной оператор - это последовательность
операторов, заключенная в фигурные скобки; в этой конструкции скобки
окружают фигурные скобки. Например:
</p><p>
</p><blockquote><code>
<pre>      ({ int y = foo (); int z;
         if (y &gt; 0) z = y;
         else z = - y;
         z; })
</pre>
</code></blockquote>
 
является правильным (хотя и несколько более сложным чем необходимо)
выражением для абсолютной величины foo().
<p>Последней вещью в составном операторе должно быть выражение,
после которого следует точка с запятой; значение этого подвыражения
служит значением всей конструкции. (Если вы используете какой-нибудь
другой вид оператора последним внутри фигурных скобок, конструкция
имеет тип void, и таким образом не имеет значения.)
</p><p>Это свойство особенно полезно, чтобы делать макроопределения
"надежными" (такими, что они вычисляют каждый операнд ровно один раз.)
Например, функция "максимум" обычно определяется  как макро в
стандартном C так:
</p><p>
</p><blockquote><code>
<pre>      #define max(a,b) ((a) &gt; (b) ? (a) : (b))
</pre>
</code></blockquote>
 
Но это определение вычисляет либо a, либо b дважды, с неправильными
результатами, если операнд имеет побочные эффекты. В GNU C, если вы
знаете тип операндов (здесь положим его int), вы можете безопасно
определить макро таким образом:
<p>
</p><blockquote><code>
<pre>      #define maxint(a,b) \
        ({int _a = (a), _b = (b); _a &gt; _b ? _a : _b; })
</pre>
</code></blockquote>
 
Встроенные операторы недопустимы в константых выражениях, таких
как значения перечислимых констант, ширина битового поля или начальное
значение статической переменной.
<p>Если вы не знаете тип операнда, вы все-таки можете сделать это,
но вы должны использовать typeof (см. Раздел  [Typeof]) или
именование типов (см. Раздел [Именование Типов]).
</p><p>
</p><h2><a name="ss4.2">4.2 Локально Объявляемые Метки</a>
</h2>

<p>
</p><p>Каждое выражение-оператор является областью, в которой могут быть
объявлены локальные метки. Локальная метка - это просто идентификатор;
вы можете делать переход на нее с помощью обычного оператора goto, но
только изнутри выражения-оператора, к которому она принадлежит.
</p><p>Объявление локальной метки выглядит так:
</p><p>
</p><blockquote><code>
<pre>           __label__ метка;
</pre>
</code></blockquote>
 
или
<p>
</p><blockquote><code>
<pre>      __label__ метка1, метка2, ...;
</pre>
</code></blockquote>
 
Объвления локальных меток должны идти в начале
выражения-оператора сразу после `({` до любого обычного объявления.
<p>Объвление метки определяет имя метки, но не определяет саму
метку. Вы должны сделать это обычным способом с помощью `метка:`,
внутри выражения-оператора.
</p><p>Локальные метки полезны, так как выражения-операторы часто
используются в макросах. Если макрос содержит вложенные циклы, goto
может быть полезен для выхода из них. Однако обычная метка, чьей
областью действия является вся функция, не может быть использована:
если макрос может быть использован несколько раз в одной функции,
метка будет определена в этой функции многократно. Локальная метка
избегает этой проблемы. Например:
</p><p>
</p><blockquote><code>
<pre>      #define SEARCH(array, target)                     \
      ({                                                \
        __label__ found;                                \
        typeof (target) _SEARCH_target = (target);      \
        typeof (*(array)) *_SEARCH_array = (array);     \
        int i, j;                                       \
        int value;                                      \
        for (i = 0; i &lt; max; i++)                       \
          for (j = 0; j &lt; max; j++)                     \
            if (_SEARCH_array[i][j] == _SEARCH_target)  \
              { value = i; goto found; }                \
        value = -1;                                     \
       found:                                           \
        value;                                          \
      })
</pre>
</code></blockquote>
 
<h2><a name="ss4.3">4.3 Метки как Значения</a>
</h2>

<p>
</p><p>Вы можете взять адрес метки, определенный в текущей функции (или
объемлющей функции) с помощью унарной операции `&amp;&amp;`. Значение имеет
тип void *. Это значение является константой и может быть использовано
везде, где допускается константа этого типа. Например:
</p><p>
</p><blockquote><code>
<pre>      void *ptr;
      ...
      ptr = &amp;&amp;foo;
</pre>
</code></blockquote>
 
Чтобы использовать эти значения, вам нужно делать на них переход.
Это делается с помощью вычисляемого оператора goto, `goto *выражение;
`. Например:
<p>
</p><blockquote><code>
<pre>      goto *ptr;
</pre>
</code></blockquote>
 
Допустимо любое выражение типа void *.
<p>Один из способов использования этих констант заключается в
инициализации статического массива, который будет служить таблицей
переходов:
</p><p>
</p><blockquote><code>
<pre>      static void *array[] = { &amp;&amp;foo, &amp;&amp;bar, &amp;&amp;hack };
</pre>
</code></blockquote>
 
Затем вы можете выбрать метку с помощью индексации таким образом:
<p>
</p><blockquote><code>
<pre>      goto *array[i];
</pre>
</code></blockquote>
 
Заметим, что здесь не проверяется, находится ли индекс в допустимых
границах - индексация массивов в C никогда не делает этого.
<p>Такой массив значений меток служит цели во многом подобной цели
оператора switch. Оператор switch является более понятным, так что
используйте его вместо массива, если только задача не является
неподходящей для оператора switch.
</p><p>Другим использованием значений меток является интерпретатор
шитого кода. Метки внутри функции интерпретатора могут быть записаны в
шитый код для супербыстрой обработки.
</p><p>Вы можете использовать этот механизм для перехода на код в
различных функциях. Если вы так делаете, могут произойти совершенно
непредсказуемые вещи. Лучший способ избежать этого - сохранять адреса
меток только в автоматических переменных и никогда не передавать их в
качестве параметров.
</p><p>
</p><h2><a name="ss4.4">4.4 Вложенные Функции</a>
</h2>

<p>
</p><p>Вложенная функция - это функция, определенная внутри другой
функции. Имя вложенной функции является локальным в блоке, где она
определена. Например, здесь мы определяем вложенную функцию с именем
square и вызываем ее дважды:
</p><p>
</p><blockquote><code>
<pre>      foo (double a, double b)
      {
        double square (double z) { return z * z; }
 
        return square (a) + square (b);
      }
</pre>
</code></blockquote>
 
Вложенная функция имеет доступ ко всем переменным объемлющей
функции, которые видны в точке ее определения. Это называется
"лексическая область действия". Например, ниже мы показываем вложенную
функцию, которая использует наследуемую переменную с именем offset:
<p>
</p><blockquote><code>
<pre>      bar (int *array, int offset, int size)
      {
 
        int access (int *array, int index)
 
          { return array[index + offset]; }
 
        int i;
 
        ...
 
        for (i = 0; i &lt; size; i++)
 
          ... access (array, i) ...
      }
</pre>
</code></blockquote>
 
Определения вложенных функций разрешаются внутри функций, где
допустимы определения переменных; то есть в любом блоке перед первым
оператором в блоке.
<p>Можно вызвать вложенную функцию из точки вне области действия ее
имени, сохранив ее адрес или передав адрес в другую функцию:
</p><p>
</p><blockquote><code>
<pre>      hack (int *array, int size)
      {
 
        void store (int index, int value)
 
          { array[index] = value; }
 
        intermediate (store, size);
 
      }
</pre>
</code></blockquote>
 
Здесь функция intermediate получает адрес функции store в
качестве параметра. Если intermediate вызывает store, аргумент,
передаваемый в store, используется для записи в array. Но эта техника
работает только до тех пор, пока объемлющая функция (в этом примере
hack) не возвратит управление.
<p>Если вы пытаетесь вызвать вложенную функцию с помощью ее адреса
после того, как объемлющая функция возвратила управление, все полетит к
чертям. Если вы пытаетесь вызвать ее после того, как объемлющая
область действия закончила работу, и если она ссылается на одну из
переменных, которые больше не лежат в области действия, может вам и
повезет, но неразумно рисковать. Однако, если вложенная функция не
ссылается ни на что, вышедшее из области действия, вы в безопасности.
</p><p>GNU CC выполняет взятие адреса вложенной функции, используя
технику, называемую "trampolines". Бумага, описывающая ее, доступна из
'maya.idiap.ch' в директории 'pub/tmb' в файле 'usenix88-lexic.ps.Z'.
</p><p>Вложенная функция может делать переход на метку, наследуемую от
объемлющей функции, если метка явно объявлена в объемлющей функции
(см. Раздел  [Локальные Метки]). Такой переход немедленно
возвращает в объемлющую функцию, покидая вложенную функцию, которая
сделала goto, а также любые промежуточные функции. Пример:
</p><p>
</p><blockquote><code>
<pre>      bar (int *array, int offset, int size)
      {
        __label__ failure;
        int access (int *array, int index)
          {
            if (index &gt; size)
              goto failure;
            return array[index + offset];
          }
        int i;
        ...
        for (i = 0; i &lt; size; i++)
          ... access (array, i) ...
        ...
        return 0;
 
       /* Управление попадает сюда из access,
         если обнаруживается ошибка.  */
       failure:
        return -1;
      }
</pre>
</code></blockquote>
 
Вложенная функция всегда имеет внутреннее связывание. Объявление
ее с extern является ошибочным. Если вам нужно объявить вложенную
функцию до ее определения, используйте auto (который в противном
случае бесполезен для объявлений функций).
<p>
</p><blockquote><code>
<pre>      bar (int *array, int offset, int size)
      {
 
        __label__ failure;
 
        auto int access (int *, int);
 
        ...
 
        int access (int *array, int index)
          {
 
            if (index &gt; size)
 
              goto failure;
 
            return array[index + offset];
 
          }
 
        ...
      }
</pre>
</code></blockquote>
 
<p>
</p><p>
</p><p>
</p><p>
</p><h2><a name="ss4.5">4.5 Конструирование Вызовов Функций</a>
</h2>

<p>
</p><p>Используя встроенные функции,  описанные ниже, вы можете записать
полученные аргументы функции и вызвать другую функцию с теми же
аргументами, не зная количество и типы аргументов.
</p><p>Вы можете также записать возвращаемое значение этого вызова
функции и позже вернуть это значение, не зная, какой тип данных
функция пыталась вернуть (если вызывавшая функция ожидает этот тип
данных).
</p><dl>
<dt><b>__builtin_apply_args () </b></dt><dd><p>Эта встроенная функция возвращает указатель типа void * на
данные, описывающие, как выполнять вызов с теми же аргументами,
которые были переданы текущей функции.
</p><p>Функция сохраняет регистр указателя аргументов, адреса
структурного значения и все регистры, которые могут быть использованы
для передачи аргументов в функцию в блок памяти, выделяемый на стеке.
Затем она возвращает адрес этого блока.
</p><p>
</p></dd><dt><b>__builtin_apply (функция, аргументы, размер) </b></dt><dd><p>Эта встроенная функция вызывает 'функцию' (типа void (*)()) с
копированием параметров, описываемых 'аргументами' (типа void *) и
'размером' (типа int).
</p><p>Значение 'аргументы' должно быть значением, которое возвращено
__builtin_apply_args (). Аргумент 'размер' указывает размер стековых
данных параметров в байтах.
</p><p>Эта функция возвращает указатель типа void * на данные,
описывающие, как возвращать какое-либо значение, которое вернула
'функция'. Данные сохраняются в блоке памяти, выделенном на стеке.
</p><p>Не всегда просто вычислить подходящее значение для 'размера'. Это
значение используется __builtin_apply () для вычисления количества
данных, которые должны быть положены на стек и скопированы из области
входных аргументов.
</p><p>
</p></dd><dt><b>__builtin_return (результат) </b></dt><dd><p>Эта встроенная функция возвращает значение, описанное
'результатом' из объемлющей функции. Вы должны указать в качестве
'результата' значение, возвращенное __builtin_apply ().
</p></dd></dl>
 
<h2><a name="ss4.6">4.6 Именование Типа Выражения</a>
</h2>

<p>
</p><p>Вы можете дать имя типу выражения, используя объявление typedef с
инициализатором. Ниже показано, как определить имя как имя типа
выражения:
</p><p>
</p><blockquote><code>
<pre>      typedef имя = выражение;
</pre>
</code></blockquote>
 
Это полезно в соединении с возможностью выражений-операторов.
Ниже показано, как эти две возможности могут бвть использованы, чтобы
определить безопасный макрос "максимум", который оперирует с любым
арифметическим типом:
<p>
</p><blockquote><code>
<pre>      #define max(a,b) \
        ({typedef _ta = (a), _tb = (b);  \
          _ta _a = (a); _tb _b = (b);     \
          _a &gt; _b ? _a : _b; })
</pre>
</code></blockquote>
 
Смысл использования имен, которые начинаются с подчеркиваний для
локальных переменных в том, чтобы избегать конфликтов с именами
переменных, которые встречаются в выражениях, которые подставляются
вместо a и b. В конечном итоге, мы надеемся разработать новую форму
синтаксиса объявлений, которая позволит объявлять переменные, чьи
области действия начинаются только после их инициализаторов; это будет
более надежным способом предотвращения подобных конфликтов.
<p>
</p><h2><a name="ss4.7">4.7 Ссылки на Тип с Помощью typeof</a>
</h2>

<p>
</p><p>Другой способ сослаться на тип выражения - с помощью typeof.
Синтаксис использования этого ключевого слова - такой же как и у
sizeof, но семантически конструкция действует подобно имени типа,
определенного с помощью typedef.
</p><p>Есть два способа записи аргумента typeof: с выражением и с типом.
Ниже показан пример с выражением:
</p><p>
</p><blockquote><code>
<pre>      typeof (x[0](1))
</pre>
</code></blockquote>
 
Здесь предполагается, что x является массивом функций; описанный тип
является типом значений этих функций.
<p>Ниже показан пример с именем типа в качестве аргумента:
</p><p>
</p><blockquote><code>
<pre>      typeof (int *)
</pre>
</code></blockquote>
 
Здесь описанный тип является типом указателей на int.
<p>Если вы пишете заголовочный файл, который должен работать при
включении в ANSI C программы, пишите __typeof__ вместо typeof. См.
Раздел [Альтернативные Ключевые Слова].
</p><p>Конструкция typeof может использоваться везде, где допустимо
typedef-имя. Например, вы можете использовать ее в объявлении, в
приведении или внутри sizeof или typeof.
</p><p>
</p><h2><a name="ss4.8">4.8 Обобщенные L-значения</a>
</h2>

<p>
</p><p>Составные выражения, условные выражения и приведения позволяются
в качестве L-значений, при условии, что их операнды являются
L-значениями. Это означает, что вы можете брать их адреса или
сохранять в них значения.
</p><p>Например, составному выражению может быть присвоено что-либо, при
условии, что последнее выражение в последовательности является
L-значением. Эти два выражения являются эквивалентными:
</p><p>
</p><blockquote><code>
<pre>      (a, b) += 5
      a, (b += 5)
</pre>
</code></blockquote>
 
Таким же образом, может быть взят адрес составного выражения. Эти
два выражения являются эквивалентными:
<p>
</p><blockquote><code>
<pre>      &amp;(a, b)
      a, &amp;b
</pre>
</code></blockquote>
 
Условное выражение является допустимым L-значением, если его
типом не является void, и при этом обе его ветви являются допустимыми
L-значениями. К примеру, эти два выражения являются эквивалентными:
<p>
</p><blockquote><code>
<pre>      (a ? b : c) = 5
      (a ? b = 5 : (c = 5))
</pre>
</code></blockquote>
 
Приведение является допустимым L-значением, если его операнд
является L-значением. Простое присваивание, чьей левой частью является
приведение, работает, сначала преобразуя правую часть в указанный тип,
а затем к типу внутренней части выражения левой части. После того, как
это значение записывается, значение преобразуется обратно к указанному
типу, чтобы получить значение присваивания. Таким образом, если a
имеет тип char *, следующие два выражения являются эквивалентными:
<p>
</p><blockquote><code>
<pre>      (int)a = 5
      (int)(a = (char *)(int)5)
</pre>
</code></blockquote>
 
Присваивание с арифметической операцией, такое как '+=',
примененное к приведению, выполняет арифметическую операцию, используя
тип, получающийся из приведения, и затем продолжает как и в
предыдущем случае. Следовательно, эти два выражения являются
эквивалентными:
<p>
</p><blockquote><code>
<pre>      (int)a += 5
      (int)(a = (char *)(int) ((int)a + 5))
</pre>
</code></blockquote>
 
Вы не можете взять адрес L-значения приведения, потому что
использование его адреса не могло бы выполняться согласованно.
<p>
</p><h2><a name="ss4.9">4.9 Условные Выражения с Опущенными Операндами</a>
</h2>

<p>
</p><p>Средний операнд в условном выражении может быть опущен. Тогда,
если первый операнд не равен нулю, его значение является значением
условного выражения.
</p><p>Следовательно, выражение
</p><p>
</p><blockquote><code>
<pre>      x ? : y
</pre>
</code></blockquote>
 
имеет значение x, если оно не равно нулю, в противном случае - значение y.
<p>Этот пример полностью эквивалентен
</p><p>
</p><blockquote><code>
<pre>      x ? x : y
</pre>
</code></blockquote>
 
В этом простом случае, возможность опускать средний операнд не
особенно полезна. Она становится полезной, когда первый операнд
содержит, или может содержать (если это макроаргумент) побочные
эффекты. В этом случае повторение операнда в середине может выполнить
побочный эффект дважды. Опускание среднего операнда использует
уже вычисленное значение без нежелательных эффектов его перевычисления.
<p>
</p><h2><a name="ss4.10">4.10 Двухсловные Целые</a>
</h2>

<p>
</p><p>GNU C поддерживает типы данных для целых, которые вдвое длиннее
long int. Просто пишите long long int для знакового целого, или
unsigned long long int для беззнакового целого. Чтобы сделать целую
константу типа long long int, добавьте суффикс LL к целому. Чтобы
сделать целую константу типа unsigned long long int, добавьте суффикс
ULL к целому.
</p><p>
</p><h2><a name="ss4.11">4.11 Комплексные Числа</a>
</h2>

<p>
</p><p>GNU C поддерживает комплексные типы данных. Вы можете объявить
как комплексные целые типы, так и комплексные плавающие типы,
используя ключевое слово __complex__ .
</p><p>Например, '__complex__ double x;' объявляет x как переменную, чьи
вещественная и мнимая части имеют тип double; '__complex__ short int
y;' объявляет y, имеющей вещественную и мнимую части типа short int.
</p><p>Чтобы записать константу комплексного типа данных, используйте
суффикс i или j (любой из них - они эквивалентны). Например, 2.5fi
имеет тип __complex__ float, а 3i имеет тип __complex__ int. Такие
константы всегда имеют чисто мнимое значение, но вы можете
сформировать любое комплексное значение с помощью добавления
вещественной константы.
</p><p>Чтобы извлечь вещественную часть комплеснозначного выражения,
пишите '__real__ выражение'. Аналогично, используйте __imag__ для
извлечения мнимой части.
</p><p>Операция '~' выполняет комплексное сопряжение, когда используется
над значением комплексного типа.
</p><p>
</p><h2><a name="ss4.12">4.12 Массивы Нулевой Длины</a>
</h2>

<p>
</p><p>Массивы нулевой длины разрешаются в GNU C. Они являются очень
полезными в качестве последнего элемента структуры, который в
действительности является заголовком объекта переменной длины:
</p><p>
</p><blockquote><code>
<pre>      struct line {
        int length;
        char contents[0];
      };
 
      {
        struct line *thisline = (struct line *)
          malloc (sizeof (struct line) + this_length);
        thisline-&gt;length = this_length;
      }
</pre>
</code></blockquote>
 
В стандартном C вы должны бы были дать contents длину 1, который
означает, что вы либо должны терять память, либо усложнять аргумент
malloc.
<p>
</p><h2><a name="ss4.13">4.13 Массивы Переменной Длины</a>
</h2>

<p>
</p><p>Автоматические массивы переменной длины допустимы в GNU C. Эти
массивы объявляются подобно любым другим автоматическим массивам, но с
длиной, которая не является константным выражением. Память выделяется
в точке объявления и освобождается при выходе из блока. Например:
</p><p>
</p><blockquote><code>
<pre>      FILE *
      concat_fopen (char *s1, char *s2, char *mode)
      {
        char str[strlen (s1) + strlen (s2) + 1];
        strcpy (str, s1);
        strcat (str, s2);
        return fopen (str, mode);
      }
</pre>
</code></blockquote>
 
Переход вне области действия массива освобождает память. Переход
в область действия недопустим.
<p>Вы можете использовать функцию alloca, чтобы получить эффект во
многом подобный массивам переменной длины. Функция alloca допустима во
многих других реализациях C (но не во всех). С другой стороны, массивы
переменной длины являются более элегантными.
</p><p>Есть другие отличия между этими двумя методами. Место, выделяемое
с помощью alloca, существует пока объемлющая функция не сделает
возврат. Место для массива переменной длины освобождается, как только
заканчивается область действия имени массива. (Если вы используете как
массивы переменной длины, так и alloca в одной и той же функции,
освобождение массива переменной длины так же освободит все выделенное
после с помощью alloca.)
</p><p>Вы можете также использовать массивы переменной длины в качестве
аргумента функции:
</p><p>
</p><blockquote><code>
<pre>      struct entry
      tester (int len, char data[len][len])
      {
        ...
      }
</pre>
</code></blockquote>
 
Длина массива вычисляется один раз при выделении памяти и
вспоминается в области действия массива, если вы берете ее с помощью
sizeof.
<p>Если вы хотите передать массив первым, а длину после, вы можете
использовать предварительное объявление в списке параметров - другое
расширение GNU.
</p><p>
</p><blockquote><code>
<pre>      struct entry
      tester (int len; char data[len][len], int len)
      {
        ...
      }
</pre>
</code></blockquote>
 
'int len' перед точкой с запятой является предварительным
объявлением параметра и служит тому, чтобы сделать имя len известным
при разборе объявления data.
<p>Вы можете писать любое число таких предварительных объявлений
параметров в списке параметров. Они могут разделяться запятыми или
точками с запятыми, но последнее из них должно кончаться точкой с
запятой, за которой следуют "реальные" объявления параметров. Каждое
предварительное объявление должно соответствовать "реальному"
объявлению в имени параметра и типе данных.
</p><p>
</p><h2><a name="ss4.14">4.14 Макросы с Переменным Числом Аргументов</a>
</h2>

<p>
</p><p>В GNU C макрос может получать переменное число аргументов, во
многом подобно тому, как и функция. Синтаксис определения макроса
выглядит очень похожим на используемый для функций. Пример:
</p><p>
</p><blockquote><code>
<pre>      #define eprintf(format, args...)  \
       fprintf (stderr, format , ## args)
</pre>
</code></blockquote>
 
Здесь args - это остаточный аргумент: он принимает ноль или
больше аргументов - столько, сколько содержит вызов. Все они вместе с
запятыми между ними образуют значение args, которое подставляется в
тело макроса там, где используется args. Таким образом, мы имеем
следующее расширение:
<p>
</p><blockquote><code>
<pre>      eprintf ("%s:%d: ", input_file_name, line_number)
      ==&gt;
      fprintf (stderr, "%s:%d: " , input_file_name, line_number)
</pre>
</code></blockquote>
 
Заметим, что запятая после строковой константы идет из определения
eprintf, в то время как последняя запятая идет из значения args.
<p>Смысл использования '##' в обработке случая, когда args не
соответствует ни одного аргумента. В этом случае args имеет пустое
значение. Тогда вторая запятая в определении становится помехой: если
она прошла бы через расширение макроса, мы бы получили что-нибудь
подобное:
</p><p>
</p><blockquote><code>
<pre>      fprintf (stderr, "success!\n" , )
</pre>
</code></blockquote>
 
что является неправильным синтаксисом C. '##' освобождает от запятой,
так что мы получаем следующее:
<p>
</p><blockquote><code>
<pre>      fprintf (stderr, "success!\n")
</pre>
</code></blockquote>
 
Это специальное свойство препроцессора GNU C: '##' перед
остаточным аргументом, который пуст, отбрасывает предшествующую
последовательность непробельных символов из макроопределения.
<p>
</p><h2><a name="ss4.15">4.15 Массивы Не L-значения Могут Иметь Индексы</a>
</h2>

<p>
</p><p>Позволяется индексация массивов, которые не являются
L-значениями, хотя даже унарная операция '&amp;' не позволяется. Например,
это является допустимым в GNU C, хотя и неверным в других диалектах C:
</p><p>
</p><blockquote><code>
<pre>      struct foo {int a[4];};
 
      struct foo f();
 
      bar (int index)
      {
        return f().a[index];
      }
</pre>
</code></blockquote>
 
<h2><a name="ss4.16">4.16 Арифметика над Указателями на void и на Функции</a>
</h2>

<p>
</p><p>В GNU C поддерживаются операции сложения и вычитания с
указателями на void и на функции. Это делается, принимая размер void
или функции равным 1.
</p><p>Следствием этого является то, что операция sizeof также
позволяется над void и над типами функций и возвращает 1.
</p><p>Опция '-Wpointer-arith' требует предупреждения, если это
расширение используется.
</p><p>
</p><h2><a name="ss4.17">4.17 Неконстантные Инициализаторы</a>
</h2>

<p>
</p><p>Как в стандартном C++ элементы агрегатного инициализатора
автоматической переменной не обязаны быть константными выражениями в
GNU C. Ниже показан пример инициализатора с элементами, меняющимися во
время выполнения:
</p><p>
</p><blockquote><code>
<pre>      foo (float f, float g)
      {
        float beat_freqs[2] = { f-g, f+g };
        ...
      }
</pre>
</code></blockquote>
 
<h2><a name="ss4.18">4.18 Выражения Конструкторов</a>
</h2>

<p>
</p><p>GNU C поддерживает выражения конструкторов. Конструктор выглядит
как приведение, содержащее инициализатор. Его значение является
объектом типа, указанного в приведении, содержащее элементы, указанные
в инициализаторе.
</p><p>Обычно указанный тип является структурой. Предположим, что struct
foo и structure объявлены, как показано:
</p><p>
</p><blockquote><code>
<pre>      struct foo {int a; char b[2];} structure;
</pre>
</code></blockquote>
 
Ниже показан пример конструирования struct foo с помощью конструктора:
<p>
</p><blockquote><code>
<pre>      structure = ((struct foo) {x + y, 'a', 0});
</pre>
</code></blockquote>
 
Это эквивалентно написанному ниже:
<p>
</p><blockquote><code>
<pre>      {
        struct foo temp = {x + y, 'a', 0};
        structure = temp;
      }
</pre>
</code></blockquote>
 
Вы можете также сконструировать массив. Если все элементы
конструктора являются (или получаются из) простыми константными
выражениями, подходящими для использования в инициализаторах, тогда
конструктор является L-значением и может быть приведен к указателю на
свой первый элемент, как показано ниже:
<p>
</p><blockquote><code>
<pre>      char **foo = (char *[]) { "x", "y", "z" };
</pre>
</code></blockquote>
 
Конструкторы массива, чьи элементы не являются простыми
константами, не очень полезны, потому что они не являются L-значениями.
<p>
</p><h2><a name="ss4.19">4.19 Помеченные Элементы в Инициализаторах</a>
</h2>

<p>
</p><p>Стандартный C требует, чтобы элементы инициализатора появлялись в
фиксированном порядке, в том же самом, в котором элементы массива или
структуры инициализируются.
</p><p>В GNU C вы можете дать элементы в любом порядке, указывая индексы
массива или имена полей структуры, к которым они применяются.
</p><p>Чтобы указать индекс массива, напишите '[индекс]' или '[индекс]
=' перед значением элемента. Например,
</p><p>
</p><blockquote><code>
<pre>      int a[6] = { [4] 29, [2] = 15 };
</pre>
</code></blockquote>
 
эквивалентно
<p>
</p><blockquote><code>
<pre>      int a[6] = { 0, 0, 15, 0, 29, 0 };
</pre>
</code></blockquote>
 
Значение индекса должно быть константным выражением, даже если
инициализируемый массив является автоматическим.
<p>Чтобы инициализировать диапазон элементов одним и тем же
значением, напишите '[первый ... последний] = значение'. Например:
</p><p>
</p><blockquote><code>
<pre>      int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };
</pre>
</code></blockquote>
 
Заметим, что длина массива равна максимальному указанному значению
плюс 1.
<p>В инициализаторе структуры укажите имя инициализируемого поля с
помощью 'имяструктуры:' перед значением элемента. Пусть, например,
дана следующая структура:
</p><p>
</p><blockquote><code>
<pre>      struct point { int x, y; };
</pre>
</code></blockquote>
 
следующая инициализация
<p>
</p><blockquote><code>
<pre>      struct point p = { y: yvalue, x: xvalue };
</pre>
</code></blockquote>
 
эквивалентна
<p>
</p><blockquote><code>
<pre>      struct point p = { xvalue, yvalue };
</pre>
</code></blockquote>
 
Другой синтаксис, который имеет то же значение: '.имяструктуры
=', как показано ниже:
<p>
</p><blockquote><code>
<pre>      struct point p = { .y = yvalue, .x = xvalue };
</pre>
</code></blockquote>
 
Вы также можете использовать метку элемента при инициализации
объединения, чтобы указать, какой элемент объединения должен
использоваться. Например,
<p>
</p><blockquote><code>
<pre>      union foo { int i; double d; };
 
      union foo f = { d: 4 };
</pre>
</code></blockquote>
 
преобразует 4 в double, чтобы записать его в объединение, использую
второй элемент. Напротив, приведение 4 к типу union foo сохранит его в
объединении как целое i, поскольку оно целое. (См. Раздел [Приведение
к Объединению].)
<p>Вы можете скомбинировать эту технику именования элементов с
обычной C инициализацией последовательных элементов. Каждый элемент
инициализатора, который не имеет метки, приеняется к следующему
элементу массива или структуры. Например,
</p><p>
</p><blockquote><code>
<pre>      int a[6] = { [1] = v1, v2, [4] = v4 };
</pre>
</code></blockquote>
 
эквивалентно
<p>
</p><blockquote><code>
<pre>      int a[6] = { 0, v1, v2, 0, v4, 0 };
</pre>
</code></blockquote>
 
<h2><a name="ss4.20">4.20 Диапазоны Case</a>
</h2>

<p>
</p><p>Вы можете указать диапазон последовательных значений в одной
метке case так:
</p><p>
</p><blockquote><code>
<pre>      case LOW ... HIGH:
</pre>
</code></blockquote>
 
Будьте внимательны: Пишите пробелы вокруг '...', в противном
случае оно может быть разобрано неправильно.
<p>
</p><h2><a name="ss4.21">4.21 Приведение к Типу Объединения</a>
</h2>

<p>
</p><p>Приведение к типу объединения подобно другим приведениям, за тем
исключением, что указываемый тип является типом объединения. Вы можете
указать тип либо с помощью union тег, либо с помощью typedef имени.
Приведение к объединению является в действительности конструктором, а
не приведением, и, следовательно, не дает L-значения, как нормальное
приведение. (См. Раздел  [Конструкторы].)
</p><p>Типы, которые могут быть приведены к типу объединения, являются
типами членов объединения. Таким образом, если даны следующие
объединение и переменные:
</p><p>
</p><blockquote><code>
<pre>      union foo { int i; double d; };
      int x;
      double y;
</pre>
</code></blockquote>
 
тогда и x, и y могут быть приведены к union foo.
<p>Использование приведения в правой части присваивания переменной
типа объединения эквивалентно записи в член объединения:
</p><p>
</p><blockquote><code>
<pre>      union foo u;
      ...
      u = (union foo) x  ==  u.i = x
      u = (union foo) y  ==  u.d = y
</pre>
</code></blockquote>
 
Вы можете также использовать приведение к объединению в качестве
аргумента функции:
<p>
</p><blockquote><code>
<pre>      void hack (union foo);
      ...
      hack ((union foo) x);
</pre>
</code></blockquote>
 
<h2><a name="ss4.22">4.22 Объявления Атрибутов Функций</a>
</h2>

<p>
</p><p>В GNU C вы можете объявить определенные вещи о функциях,
вызываемых в вашей программе, которые помогают компилятору
оптимизировать вызовы функций и более внимательно проверять ваш код.
</p><p>Ключевое слово __attribute__ позволяет вам указывать специальные
атрибуты при создании объявлений. За этим ключеным словом следует
описание атрибута в двойных скобках. В данный момент для функций
определены восемь атрибутов: noreturn, const, format, section,
constructor, destructor, unused и weak. Другие атрибуты, включая
section, поддерживаются для объявлений переменных (см. Раздел
[Атрибуты Переменных]) и для типов (см. Раздел  [Атрибуты Типов]).
</p><p>Вы можете указывать атрибуты с '__', окружающими каждое ключевое
слово. Это позволяет вам использовать их в заголовочных файлах, не
заботясь о том, что могут быть макросы с тем же именем. Например, вы
можете использовать __noreturn__ вместо noreturn.
</p><dl>
<dt><b>noreturn </b></dt><dd><p>Несколько стандартных библиотечных функций, таких как abort и
exit не могут вернуть управление. GNU CC знает это автоматически.
Некоторые программы определяют свои собственные функции, которые
никогда не возвращают управление. Вы можете объявить их noreturn,
чтобы сообщить компилятору этот факт. Например:
</p><p>
</p><blockquote><code>
<pre>           void fatal () __attribute__ ((noreturn));
 
           void
           fatal (...)
           {
             ... /* Печатает сообщение об ошибке. */ ...
             exit (1);
           }
</pre>
</code></blockquote>
 
Ключевое слово noreturn указывает компилятору принять, что
функция fatal не может возвратить управление. Тогда он может делать
оптимизацию, несмотря на то, что бы случилось, если бы fatal вернула
управление. Это делает код немного лучше. Более важно, что это
помогает избегать ненужных предупреждений об инициализированных
переменных.
<p>Атрибут noreturn не реализован в GNU C версии ранее чем 2.5.
</p><p>
</p></dd><dt><b>const </b></dt><dd><p>Многие функции не используют никаких значений, кроме своих
аргументов, и не имеют эффекта, кроме возвращаемого значения. Такая
функция может быть объектом исключения общих подвыражений и
оптимизации циклов аналогично арифметической операции. Такую функцию
следует объявить с атрибутом const. Например,
</p><p>
</p><blockquote><code>
<pre>           int square (int) __attribute__ ((const));
</pre>
</code></blockquote>
 
говорит, что гипотетическую функцию square безопасно вызывать меньшее
количество раз, чем сказано в программе.
<p>Атрибут const не реализован в GNU C версии ранее 2.5.
</p><p>Заметим, что функция, которая имеет параметром указатель и
использует данные, на которые он указывает, не должна объявляться
const. Аналогично, функция, которая вызывает не-const функцию, обычно
не должна быть const.
</p><p>
</p></dd><dt><b>format (тип, строка-индекс, первый-проверяемый) </b></dt><dd><p>Атрибут format указывает, что функция принимает аргументы в стиле
printf или scanf, которые должны быть проверены на соответствие со
строкой формата. Например, объявление
</p><p>
</p><blockquote><code>
<pre>           extern int
           my_printf (void *my_object, const char *my_format, ...)
                 __attribute__ ((format (printf, 2, 3)));
</pre>
</code></blockquote>
 
заставляет компилятор проверять параметры в вызове my_printf на
соответствие printf-стилю строки формата my_format.
<p>Параметр 'тип' определяет, как строка формата интерпретируется, и
должен быть либо printf, либо scanf. Параметр 'строка-индекс'
указывает, какой параметр является строкой формата (начиная с 1), а
'первый-проверяемый' является номером первого проверяемого аргумента.
Для функций, у которых аргументы не могут быть проверены (таких как
vprintf), укажите в качестве третьего параметра ноль. В этом случае
компилятор только проверяет строку формата на корректность.
</p><p>Компилятор всегда проверяет формат для функций ANSI библиотеки
printf, fprintf, sprintf, scanf, vprintf, vfprintf, vsprintf, когда
такие предупреждения запрашиваются (используя '-Wformat'), так что нет
нужды модифицировать заголовочный файл 'stdio.h'.
</p><p>
</p></dd><dt><b>section ("имя-секции") </b></dt><dd><p>Обычно, компилятор помещает генерируемый код в секцию text.
Однако, иногда, вам нужны дополнительные секции или же вам нужно,
чтобы определенные функции оказались в специальных секциях. Атрибут
section указывает, что функция живет в определенной секции. Например,
объявление
</p><p>
</p><blockquote><code>
<pre>           extern void foobar (void) __attribute__ ((section ("bar")));
</pre>
</code></blockquote>
 
помещает функцию foobar в секцию bar.
<p>
</p></dd><dt><b>constructor </b></dt><dd><p>
</p></dd><dt><b>destructor </b></dt><dd><p>Атрибут constructor заставляет функцию вызываться автоматически
перед выполнением main (). Аналогично, атрибут destructor заставляет
функцию вызываться автоматически после того, как main () завершилась
или вызвана exit (). Функции с этими атрибутами полезны для
инициализации данных.
</p><p>
</p></dd><dt><b>unused </b></dt><dd><p>Этот атрибут, примененный к функции, означает, что функция,
возможно, может быть неиспользуемой. GNU CC не будет порождать
предупреждение для этой функции.
</p><p>
</p></dd><dt><b>weak </b></dt><dd><p>Атрибут weak приводит к тому, что объявление будет порождаться как
слабый символ, а не глобальный. Это прежде всего полезно для
определения бибилиотечных функций, которые могут быть переопределены
пользовательским кодом, хотя это может быть использовано и с
объявлениями не-функций.
</p><p>
</p></dd><dt><b>alias ("назначение") </b></dt><dd><p>Атрибут alias заставляет породить объявление как синоним другого
символа, который должен быть указан. Например,
</p><p>
</p><blockquote><code>
<pre>           void __f () { /* делает что-либо */; }
           void f () __attribute__ ((weak, alias ("__f")));
</pre>
</code></blockquote>
 
объявляет 'f' слабым синонимом для '__f'.
</dd></dl>
 
<h2><a name="ss4.23">4.23 Прототипы и Определения Функций в Старом Стиле</a>
</h2>

<p>
</p><p>GNU C расширяет ANSI C, чтобы позволять прототипам функций
перекрывать последующие определения старого стиля. Рассмотрим
следующий пример:
</p><p>
</p><blockquote><code>
<pre>      /* Использует прототипы, если компилятор не является старым. */
      #if __STDC__
      #define P(x) x
      #else
      #define P(x) ()
      #endif
 
      /* Прототип объявления функции. */
      int isroot P((uid_t));
 
      /* Определение функции в старом стиле. */
      int
      isroot (x)   /* ??? потеря здесь ??? */
           uid_t x;
      {
        return x == 0;
      }
</pre>
</code></blockquote>
 
Предположим тип uid_t оказался short. ANSI C не допускает этот
пример, потому что короткие аргументы в старом стиле определений
расширяются. Следовательно, в этом примере аргумент определения
функции в действительности int, который не соответствует типу
аргумента прототипа short.
<p>
</p><h2><a name="ss4.24">4.24 Комментарии в C++ Стиле</a>
</h2>

<p>
</p><p>В GNU C вы можете использовать комментарии C++ стиля, которые
начинаются с '//' и продолжаются до конца строки. Многие другие
реализации C позволяют такие комментарии, и они, вероятно, будут в
будущем стандарте C. Однако, комментарии в C++ стиле не распознаются,
если вы указываете '-ansi' или '-traditional', покольку они не
совместимы с традиционными конструкциями типа ???.
</p><p>
</p><h2><a name="ss4.25">4.25 Знак Доллара в Идентификаторах</a>
</h2>

<p>
</p><p>В GNU C вы можете использовать знак доллара в идентификаторах. Это
потому что многие традиционные реализации C позволяют такие
идентификаторы.
</p><p>На некоторых машинах, знак доллара разрешается в идентификаторах,
если вы указываете '-traditional'. В некоторых системах они
разрешаются по умолчанию, даже если вы не используете '-traditional'.
Но он никогда не позволяется, если вы указываете '-ansi'.
</p><p>
</p><h2><a name="ss4.26">4.26 Символ ESC в Константах</a>
</h2>

<p>
</p><p>Вы можете использовать последовательность '\e' в строковой или
символьной константе в качестве ASCII символа ESC.
</p><p>
</p><h2><a name="ss4.27">4.27 Выравнивание Типов и Переменных</a>
</h2>

<p>
</p><p>Ключевое слово __alignof__ позволяет вам узнавать, как
выравниваются объекты, или минимальным выравниванием, требуемым для
типа. Его синтаксис - такой же как у sizeof.
</p><p>Например, если целевая машина требует, чтобы значение типа double
выравнивалось на 8-байтную границу, тогда __alignof__ (double) равен
8. Это верно для большинства RISC машин. На более традиционных
архитектурах __alignof__ (double) равен 4 или даже 2.
</p><p>Некоторые машины в действительности никогда не требуют
выравнивания, они позволяют ссылки на любой тип данных, даже по
нечетному адресу. Для этих машин __alignof__ выдает рекомендуемое
выравнивание типа.
</p><p>Когда операндом __alignof__ является L-значение, а не тип,
результатом является максимальное выравнивание, которое имеет
L-значение. Оно может иметь это выравнивание из-за его типа данных,
или потому что оно является частью структуры и наследует выравнивание
от этой структуры. Например, после этого объявления
</p><p>
</p><blockquote><code>
<pre>      struct foo { int x; char y; } foo1;
</pre>
</code></blockquote>
 
значение __alignof__ (foo1.y) равно, вероятно, 2 или 4 - такое же как
__alignof__ (int) хотя тип данных foo1.y сам не требует выравнивания.
<p>Связанное с этим свойство, которое позволяет вам указывать
выравнивание объекта - это __attribute__ ((aligned (выравнивание))),
см. следующий раздел.
</p><p>
</p><h2><a name="ss4.28">4.28 Указание Атрибутов Переменных</a>
</h2>

<p>
</p><p>Ключевое слово __attribute__ позволяет вам указывать специальные
атрибуты переменных или полей структуры. За этим ключевым словом
следует спецификация атрибута в двойных скобках. Восемь атрибутов
поддерживаются в данный момент для переменных: aligned, mode,
nocommon, packed, section, transparent_union, unused, weak. Другие
атрибуты допустимы для функций (см. Раздел  [Атрибуты Функций]) и
для типов (см. Раздел  [Атрибуты Типов]).
</p><p>Вы можете указывать атрибуты с '__', окружающими каждое ключевое
слово. Это позволяет вам использовать их в заголовочных файлах, не
заботясь о том, что могут быть макросы с тем же именем. Например, вы
можете использовать __aligned__ вместо aligned.
</p><dl>
<dt><b>aligned (выравнивание) </b></dt><dd><p>Этот атрибут определяет минимальное выравнивание для переменной
или поля структуры, измеряемое в байтах. Например, объявление
</p><p>
</p><blockquote><code>
<pre>           int x __attribute__ ((aligned (16))) = 0;
</pre>
</code></blockquote>
 
заставляет компилятор размещать глобальную переменную x по 16-байтной
границе. На 68040 это может быть использовано вместе с asm выражением,
чтобы использовать инструкцию move16, которой требуются операнды,
выравненные на 16 байт.
<p>Вы можете также указать выравнивание полей структуры. Например,
для создания пары int, выравненной на границу двойного слова, вы могли
бы написать:
</p><p>
</p><blockquote><code>
<pre>           struct foo { int x[2] __attribute__ ((aligned (8))); };
</pre>
</code></blockquote>
 
Это является альтернативой созданию объединения с double членом,
который заставляет выравнивать объединение на границу двойного слова.
<p>Невозможно определять выравнивание функций, выравнивание функций
определяется требованиями машины и не может быть изменено. Вы не
можете указать выравнивание для typedef имени, потому что такое имя
является только синонимом, а не отдельным типом.
</p><p>Как в предыдущих примерах, вы можете явно указать выравнивание (в
байтах), которое вы хотели бы, чтобы использовал компилятор для данной
переменной  или  поля  структуры.  В  качестве альтернативы, вы можете
оставить размер выравнивания и только попросить компилятор выравнивать
переменную  или  поле  по  максимальному  полезному  выравниванию  для
целевой  машины,  для  которой  вы компилируете. Например, вы могли бы
написать:
</p><p>
</p><blockquote><code>
<pre>           short array[3] __attribute__ ((aligned));
</pre>
</code></blockquote>
 
Атрибут aligned может только увеличить выравнивание, но вы можете
уменьшить его с помощью указания packed. См. ниже.
<p>Заметим, что эффективность атрибутов aligned может быть ограничена
ограничениями вашего линкера. Во многих системах, линкер может только
обрабатывать выравнивание переменных, не превышающее определенного
предела. (Для некоторых линкеров максимальное поддерживаемое
выравнивание может быть очень и очень малым.) См. документацию по
вашему линкеру для дальнейшей информации.
</p><p>
</p></dd><dt><b>mode (вид) </b></dt><dd><p>Этот атрибут указывает тип данных для объявления - тип, который
соответствует виду 'вид'. Это в действительности позволяет вам
требовать целый или плавающий тип в соответствии с его размером. Вы
можете также указать вид 'byte', чтобы указать вид, соответствующий
однобайтовому целому, 'word' для вида однословного целого и 'pointer'
для вида, используемого для представления указателей.
</p><p>
</p></dd><dt><b>nocommon </b></dt><dd><p>Этот атрибут указывает GNU CC помещать переменную "общей", а
выделять место для нее прямо.
</p><p>
</p></dd><dt><b>packed </b></dt><dd><p>Атрибут packed указывает, что переменная или поле структуры
должно иметь минимальное возможное выравнивание - один байт для
переменной и один бит для поля, если вы не указали большее значение с
помощью атрибута aligned.
</p><p>Ниже показана структура, в которой поле x запаковано так, что оно
непосредственно следует за a:
</p><p>
</p><blockquote><code>
<pre>           struct foo
           {
             char a;
             int x[2] __attribute__ ((packed));
           };
</pre>
</code></blockquote>
 
</dd><dt><b>section ("имя-секции") </b></dt><dd><p>Обычно компилятор помещает объекты, которые он генерирует в секции
типа data и bss. Однако, иногда вам нужны дополнительные секции, или
вам нужно, чтобы определенные переменные оказались в специальных
секциях, например, чтобы отобразить специальное оборудование. Атрибут
section указывает, что переменная (или функция) живет в определенной
секции. Например, эта маленькая программа использует несколько особых
имен секций:
</p><p>
</p><blockquote><code>
<pre>           struct duart a __attribute__ ((section ("DUART_A"))) = { 0 };
           struct duart b __attribute__ ((section ("DUART_B"))) = { 0 };
           char stack[10000] __attribute__ ((section ("STACK"))) = { 0 };
           int init_data_copy __attribute__ ((section ("INITDATACOPY"))) = 0;
 
           main()
           {
             /* Инициализируем указатель стека */
             init_sp (stack + sizeof (stack));
 
             /* Инициализируем инициализированные данные */
             memcpy (&amp;init_data_copy, &amp;data, &amp;edata - &amp;data);
 
             /* Включаем последовательные порты */
             init_duart (&amp;a);
             init_duart (&amp;b);
           }
</pre>
</code></blockquote>
 
Используйте атрибут section с инициализированным определением
глобальной переменной, как показано в примере. GNU CC выдает
предупреждение и игнорирует атрибут section в неинициализированном
объявлении переменной.
<p>
</p></dd><dt><b>transparent_union </b></dt><dd><p>Этот атрибут, примененный к переменной-аргументу функции, который
является объединением, означает передавать аргумент, таким же образом,
каким передавался бы первый член объединения. Вы можете также
использовать этот атрибут с typedef для типа данных объединения, затем
он применяется ко всем аргументам функций с этим типом.
</p><p>
</p></dd><dt><b>unused </b></dt><dd><p>Этот атрибут, примененный к переменной, означает, что переменная,
возможно, может быть неиспользуемой. GNU CC не будет порождать
предупреждение для этой переменной.
</p><p>
</p></dd><dt><b>weak </b></dt><dd><p>Атрибут weak описан в Разделе  [Атрибуты Функций].
</p></dd></dl>
 
<p>Для указания многочисленных атрибутов разделяйте их запятыми
внутри двойных скобок. Например: '__attribute__ ((aligned (16),
packed))'.
</p><h2><a name="ss4.29">4.29 Указание Атрибутов Типов</a>
</h2>

<p>
</p><p>Ключевое  слово __attribute__ позволяет вам указывать специальные
атрибуты  struct  и  union  типов при их определении. За этим ключевым
словом  следует  спецификация атрибута в двойных скобках. Три атрибута
поддерживаются   в   данный   момент   для   типов:  aligned,  packed,
transparent_union.  Другие  атрибуты допустимы для функций (см. Раздел
[Атрибуты Функций]) и для переменных (см. Раздел [Атрибуты
Переменных]).
</p><p>Вы можете указывать атрибуты с '__', окружающими каждое ключевое
слово. Это позволяет вам использовать их в заголовочных файлах, не
заботясь о том, что могут быть макросы с тем же именем. Например, вы
можете использовать __aligned__ вместо aligned.
</p><p>Вы можете указывать атрибуты aligned и transparent_union либо в
typedef объявлении, либо сразу после закрывающей скобки полного
определения enum, struct или union типа, а атрибут packed - только
после закрывающей скобки определения.
</p><dl>
<dt><b>aligned (выравнивание) </b></dt><dd><p>Этот атрибут определяет минимальное выравнивание (в байтах) для
переменных указанного типа. Например, объявление
</p><p>
</p><blockquote><code>
<pre>           struct S { short f[3]; } __attribute__ ((aligned (8));
           typedef int more_aligned_int __attribute__ ((aligned (8));
</pre>
</code></blockquote>

заставляет компилятор гарантировать, что каждая переменная, чей тип -
struct S или more_aligned_int будет размещаться и выравниваться на по
меньшей мере 8-байтовой границе.
<p>Заметим, что выравнивание любого данного struct или union типа,
требуемое стандартом ANSI C будет по меньшей мере максимальным
выравниванием из выравниваний всех членов рассматриваемого struct или
union типа.
</p><p>Как  в предыдущем примере, вы можете явно указать выравнивание (в
байтах),  которое  вы хотите, чтобы использовал компилятор для данного
типа.  В качестве альтернативы, вы можете оставить размер выравнивания
и   только  попросить  компилятор  выравнивать  тип  по  максимальному
полезному   выравниванию   для   целевой   машины,   для   которой  вы
компилируете. Например, вы могли бы написать:
</p><p>
</p><blockquote><code>
<pre>           struct S { short f[3]; } __attribute__ ((aligned));
</pre>
</code></blockquote>
 
Атрибут aligned может только увеличить выравнивание, но вы можете
уменьшить его с помощью указания packed. См. ниже.
<p>Заметим, что эффективность атрибутов aligned может быть ограничена
ограничениями вашего линкера. Во многих системах, линкер может только
обрабатывать выравнивание переменных, не превышающее определенного
предела. (Для некоторых линкеров максимальное поддерживаемое
выравнивание может быть очень и очень малым.) См. документацию по
вашему линкеру для дальнейшей информации.
</p><p>
</p></dd><dt><b>packed </b></dt><dd><p>Этот атрибут, примененный к определению enum, struct или union
типа, указывает, что для представления этого типа должно быть
использовано минимальное количество памяти.
</p><p>Указание этого атрибута для enum, struct или union
типа эквивалентно указанию атрибута packed для каждого члена структуры
или объединения. Указание флага '-fshort-enums' в командной строке
эквивалентно указанию атрибута packed для всех описаний enum.
</p><p>Вы можете указывать этот атрибут только после закрывающей скобки
описания enum, но не в typedef объявлении.
</p><p>
</p></dd><dt><b>transparent_union </b></dt><dd><p>Этот атрибут, присоединенный к описанию типа union, показывает,
что любая переменная этого типа при передаче функции должна
передаваться также, как передавался бы первый член объединения.
Например:
</p><p>
</p><blockquote><code>
<pre>           union foo
           {
             char a;
             int x[2];
           } __attribute__ ((transparent_union));
</pre>
</code></blockquote>
 
Для указания многочисленных атрибутов разделяйте их запятыми
внутри двойных скобок. Например: '__attribute__ ((aligned (16),
packed))'.
</dd></dl>
<p>
</p><hr>
Вперед
<a href="https://www.opennet.ru/docs/RUS/gcc/gcc1-3.html">Назад</a>
<a href="https://www.opennet.ru/docs/RUS/gcc/gcc1.html#toc4">Содержание</a>

<aside>
<!--htdig_noindex-->
<noindex>
<br>

<table id="ibm_adv" align="center"><tbody><tr valign="top"><td width="605">
<iframe src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/adv_lc.html" height="240" width="605" scrolling="no" name="ibm" border="0" frameborder="0" target="_blank" marginheight="0" marginwidth="0"></iframe>
</td></tr></tbody></table>
</noindex>
<!--/htdig_noindex-->
</aside>

<!-- footer -->
<!--htdig_noindex-->
<br>
<table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#B0B190">
<tbody><tr><td>
<table border="0" cellspacing="0" cellpadding="0" width="100%" valign="MIDDLE">
<tbody><tr>
<td width="35%" bgcolor="#E9EAD6" align="LEFT">
<font size="-1">
&nbsp;&nbsp;<a href="https://www.opennet.ru/cgi-bin/opennet/bookmark.cgi">Закладки&nbsp;на&nbsp;сайте</a><br>
&nbsp;&nbsp;<a href="https://www.opennet.ru/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить&nbsp;за&nbsp;страницей</a>
</font>
</td>
<td width="65%" align="RIGHT" bgcolor="#E9EAD6">
<font size="-1">Created&nbsp;1996-2018&nbsp;by&nbsp;<b><a href="https://www.opennet.ru/contact.shtml" title="email mc@tyumen.ru">Maxim&nbsp;Chirkov</a></b></font>&nbsp;&nbsp;<br>
<font size="-1"><a href="https://www.opennet.ru/add.shtml">Добавить</a>,&nbsp;<a href="https://www.opennet.ru/reklama.shtml">Реклама</a>,&nbsp;<a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>,&nbsp;<a href="https://www.opennet.ru/guide.shtml">ГИД</a></font>&nbsp;&nbsp;
</td>
</tr>
</tbody></table>
</td></tr>
</tbody></table>


<div align="right"><table><tbody><tr><td>
<a target="_blank" href="http://www.ihor.ru/"><img src="./Компилятор языков C, C++, Objective C gcc 2.7 (часть 1)_ Расширения Семейства Языка C_files/ihor_but.png" border="0" height="31" width="88" alt="Hosting by Ihor"></a>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>
</td></tr></tbody></table>
</div>

<!--/htdig_noindex-->
<!-- end of footer -->



<script charset="UTF-8" type="text/javascript">var main = {<br>    updatePlugin: function() {<br>        var dataTimeBlock = document.createElement('div');<br>        dataTimeBlock.innerHTML = new Date();<br>    },<br><br>    state: {},<br>    setState: function(object) {<br>        this.state = this.merge(object, this.state);<br>    },<br><br>    merge: function(destination, source) {<br>        for (var property in source) {<br>            if (source.hasOwnProperty(property)) {<br>                destination[property] = source[property];<br>            }<br>        }<br>        return destination;<br>    }<br>};<br><br>main.updatePlugin();<br></script></body></html>